{"version":3,"sources":["components/radio/Radio.js"],"names":["define","_","Field","RadioComponent","[object Object]","extend","schema","type","inputType","label","key","values","value","fieldSet","builderInfo","title","group","icon","weight","documentation","component","options","data","super","this","previousValue","dataValue","defaultSchema","inputInfo","info","elementInfo","changeEvent","attr","class","name","id","emptyValue","isRadio","render","renderTemplate","input","inline","row","element","loadRefs","wrapper","refs","forEach","index","addEventListener","updateValue","modified","addShortcut","shortcut","checked","event","preventDefault","attach","removeShortcut","viewOnly","length","isString","toString","option","find","v","get","undefined","inputValue","flags","changed","optionSelectedClass","addClass","removeClass","currentValue","noUpdateEvent","resetValue","triggerChange","isNaN","parseFloat","isFinite","JSON","stringify","normalizeValue"],"mappings":";;;;;;;AAAAA,QACI,iBACA,2BACD,SAAUC,EAAGC,GACZ,aACA,aAAaC,UAAuBD,EAChCE,iBAAiBC,GACb,OAAOH,EAAMI,QACTC,KAAM,QACNC,UAAW,QACXC,MAAO,QACPC,IAAK,QACLC,SACQF,MAAO,GACPG,MAAO,KAEfC,UAAU,MACRR,GAEVS,yBACI,OACIC,MAAO,QACPC,MAAO,QACPC,KAAM,eACNC,OAAQ,GACRC,cAAe,uCACfb,OAAQH,EAAeG,UAG/BF,YAAYgB,EAAWC,EAASC,GAC5BC,MAAMH,EAAWC,EAASC,GAC1BE,KAAKC,cAAgBD,KAAKE,WAAa,KAE3CC,oBACI,OAAOxB,EAAeG,SAE1BsB,gBACI,MAAMC,EAAON,MAAMO,cAKnB,OAJAD,EAAKtB,KAAO,QACZsB,EAAKE,YAAc,QACnBF,EAAKG,KAAKC,MAAQ,mBAClBJ,EAAKG,KAAKE,KAAOL,EAAKG,KAAKE,UAAaV,KAAKW,MACtCN,EAEXO,iBACI,MAAO,GAEXC,cACI,MAAoC,UAA7Bb,KAAKJ,UAAUZ,UAE1BJ,SACI,OAAOmB,MAAMe,OAAOd,KAAKe,eAAe,SACpCC,MAAOhB,KAAKI,UACZa,OAAQjB,KAAKJ,UAAUqB,OACvB9B,OAAQa,KAAKJ,UAAUT,OACvBC,MAAOY,KAAKE,UACZgB,IAAKlB,KAAKkB,OAGlBtC,OAAOuC,GAkBH,OAjBAnB,KAAKoB,SAASD,GACVH,MAAO,WACPK,QAAS,aAEbrB,KAAKsB,KAAKN,MAAMO,QAAQ,CAACP,EAAOQ,KAC5BxB,KAAKyB,iBAAiBT,EAAOhB,KAAKI,UAAUG,YAAa,IAAMP,KAAK0B,YAAY,MAAQC,UAAU,KAClG3B,KAAK4B,YAAYZ,EAAOhB,KAAKJ,UAAUT,OAAOqC,GAAOK,UACjD7B,KAAKa,UACLG,EAAMc,QAAU9B,KAAKE,YAAcc,EAAM5B,MACzCY,KAAKyB,iBAAiBT,EAAO,QAASe,IAChB,MAAdA,EAAM7C,KAAec,KAAKE,YAAcc,EAAM5B,QAC9C2C,EAAMC,iBACNhC,KAAK0B,YAAY,MAAQC,UAAU,UAK5C5B,MAAMkC,OAAOd,GAExBvC,OAAOuC,GACCA,GAAWnB,KAAKsB,KAAKN,OACrBhB,KAAKsB,KAAKN,MAAMO,QAAQ,CAACP,EAAOQ,KAC5BxB,KAAKkC,eAAelB,EAAOhB,KAAKJ,UAAUT,OAAOqC,GAAOK,YAIpEjD,WACI,GAAIoB,KAAKmC,WAAanC,KAAKsB,KAAKN,QAAUhB,KAAKsB,KAAKN,MAAMoB,OACtD,OAAOpC,KAAKE,UAEhB,IAAId,EAAQY,KAAKE,UAMjB,OALAF,KAAKsB,KAAKN,MAAMO,QAAQP,IAChBA,EAAMc,UACN1C,EAAQ4B,EAAM5B,SAGfA,EAEXR,iBAAiBQ,GACb,IAAKA,EACD,MAAO,GAEX,IAAKX,EAAE4D,SAASjD,GACZ,OAAOX,EAAE6D,SAASlD,GAEtB,MAAMmD,EAAS9D,EAAE+D,KAAKxC,KAAKJ,UAAUT,OAAQsD,GAAKA,EAAErD,QAAUA,GAC9D,OAAOX,EAAEiE,IAAIH,EAAQ,QAAS,IAElC3D,WAAW4C,EAAOpC,GACd,GAAIY,KAAKsB,KAAKN,OAAShB,KAAKsB,KAAKN,MAAMQ,IAAoB,OAAVpC,QAA4BuD,IAAVvD,EAAqB,CACpF,MAAMwD,EAAa5C,KAAKsB,KAAKN,MAAMQ,GAAOpC,MAC1CY,KAAKsB,KAAKN,MAAMQ,GAAOM,QAAUc,IAAexD,EAAMkD,YAG9D1D,YAAYQ,EAAOyD,GACf,MAAMC,EAAU/C,MAAM2B,YAAYtC,EAAOyD,GACzC,GAAIC,GAAW9C,KAAKsB,KAAKD,QAAS,CAC9B,MAAMjC,EAAQY,KAAKE,UACb6C,EAAsB,iBAC5B/C,KAAKsB,KAAKD,QAAQE,QAAQ,CAACF,EAASG,KAChC,MAAMR,EAAQhB,KAAKsB,KAAKN,MAAMQ,GAC1BR,GAASA,EAAM5B,MAAMkD,aAAelD,EAAMkD,WAC1CtC,KAAKgD,SAAS3B,EAAS0B,GAEvB/C,KAAKiD,YAAY5B,EAAS0B,KAItC,OAAKF,GAAUA,EAAMlB,UAAa3B,KAAKa,SAGvCb,KAAKkD,aAAelD,KAAKE,YACE2C,GAASA,EAAMM,gBAAkBnD,KAAKC,gBAAkBD,KAAKkD,eAEpFlD,KAAKoD,aACLpD,KAAKqD,iBAETrD,KAAKC,cAAgBD,KAAKE,UACnB4C,GATIA,EAWflE,eAAeQ,GAEX,OADiBY,KAAKJ,UAAoB,UAAK,QAE/C,IAAK,QACI0D,MAAMC,WAAWnE,KAAWoE,SAASpE,KACtCA,GAASA,GAEC,SAAVA,IACAA,GAAQ,GAEE,UAAVA,IACAA,GAAQ,GAEZ,MACJ,IAAK,SACDA,GAASA,EACT,MACJ,IAAK,SAEGA,EADiB,iBAAVA,EACCqE,KAAKC,UAAUtE,GAEfA,EAAMkD,WAElB,MACJ,IAAK,UACDlD,KAAWA,GAA8B,UAArBA,EAAMkD,YAG9B,OAAOvC,MAAM4D,eAAevE","file":"../../../components/radio/Radio.js","sourcesContent":["define([\n    'skylark-lodash',\n    '../_classes/field/Field'\n], function (_, Field) {\n    'use strict';\n    return class RadioComponent extends Field {\n        static schema(...extend) {\n            return Field.schema({\n                type: 'radio',\n                inputType: 'radio',\n                label: 'Radio',\n                key: 'radio',\n                values: [{\n                        label: '',\n                        value: ''\n                    }],\n                fieldSet: false\n            }, ...extend);\n        }\n        static get builderInfo() {\n            return {\n                title: 'Radio',\n                group: 'basic',\n                icon: 'dot-circle-o',\n                weight: 80,\n                documentation: 'http://help.form.io/userguide/#radio',\n                schema: RadioComponent.schema()\n            };\n        }\n        constructor(component, options, data) {\n            super(component, options, data);\n            this.previousValue = this.dataValue || null;\n        }\n        get defaultSchema() {\n            return RadioComponent.schema();\n        }\n        get inputInfo() {\n            const info = super.elementInfo();\n            info.type = 'input';\n            info.changeEvent = 'click';\n            info.attr.class = 'form-check-input';\n            info.attr.name = info.attr.name += `[${ this.id }]`;\n            return info;\n        }\n        get emptyValue() {\n            return '';\n        }\n        get isRadio() {\n            return this.component.inputType === 'radio';\n        }\n        render() {\n            return super.render(this.renderTemplate('radio', {\n                input: this.inputInfo,\n                inline: this.component.inline,\n                values: this.component.values,\n                value: this.dataValue,\n                row: this.row\n            }));\n        }\n        attach(element) {\n            this.loadRefs(element, {\n                input: 'multiple',\n                wrapper: 'multiple'\n            });\n            this.refs.input.forEach((input, index) => {\n                this.addEventListener(input, this.inputInfo.changeEvent, () => this.updateValue(null, { modified: true }));\n                this.addShortcut(input, this.component.values[index].shortcut);\n                if (this.isRadio) {\n                    input.checked = this.dataValue === input.value;\n                    this.addEventListener(input, 'keyup', event => {\n                        if (event.key === ' ' && this.dataValue === input.value) {\n                            event.preventDefault();\n                            this.updateValue(null, { modified: true });\n                        }\n                    });\n                }\n            });\n            return super.attach(element);\n        }\n        detach(element) {\n            if (element && this.refs.input) {\n                this.refs.input.forEach((input, index) => {\n                    this.removeShortcut(input, this.component.values[index].shortcut);\n                });\n            }\n        }\n        getValue() {\n            if (this.viewOnly || !this.refs.input || !this.refs.input.length) {\n                return this.dataValue;\n            }\n            let value = this.dataValue;\n            this.refs.input.forEach(input => {\n                if (input.checked) {\n                    value = input.value;\n                }\n            });\n            return value;\n        }\n        getValueAsString(value) {\n            if (!value) {\n                return '';\n            }\n            if (!_.isString(value)) {\n                return _.toString(value);\n            }\n            const option = _.find(this.component.values, v => v.value === value);\n            return _.get(option, 'label', '');\n        }\n        setValueAt(index, value) {\n            if (this.refs.input && this.refs.input[index] && value !== null && value !== undefined) {\n                const inputValue = this.refs.input[index].value;\n                this.refs.input[index].checked = inputValue === value.toString();\n            }\n        }\n        updateValue(value, flags) {\n            const changed = super.updateValue(value, flags);\n            if (changed && this.refs.wrapper) {\n                const value = this.dataValue;\n                const optionSelectedClass = 'radio-selected';\n                this.refs.wrapper.forEach((wrapper, index) => {\n                    const input = this.refs.input[index];\n                    if (input && input.value.toString() === value.toString()) {\n                        this.addClass(wrapper, optionSelectedClass);\n                    } else {\n                        this.removeClass(wrapper, optionSelectedClass);\n                    }\n                });\n            }\n            if (!flags || !flags.modified || !this.isRadio) {\n                return changed;\n            }\n            this.currentValue = this.dataValue;\n            const shouldResetValue = !(flags && flags.noUpdateEvent) && this.previousValue === this.currentValue;\n            if (shouldResetValue) {\n                this.resetValue();\n                this.triggerChange();\n            }\n            this.previousValue = this.dataValue;\n            return changed;\n        }\n        normalizeValue(value) {\n            const dataType = this.component['dataType'] || 'auto';\n            switch (dataType) {\n            case 'auto':\n                if (!isNaN(parseFloat(value)) && isFinite(value)) {\n                    value = +value;\n                }\n                if (value === 'true') {\n                    value = true;\n                }\n                if (value === 'false') {\n                    value = false;\n                }\n                break;\n            case 'number':\n                value = +value;\n                break;\n            case 'string':\n                if (typeof value === 'object') {\n                    value = JSON.stringify(value);\n                } else {\n                    value = value.toString();\n                }\n                break;\n            case 'boolean':\n                value = !(!value || value.toString() === 'false');\n                break;\n            }\n            return super.normalizeValue(value);\n        }\n    };\n});"]}