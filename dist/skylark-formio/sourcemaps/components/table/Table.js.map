{"version":3,"sources":["components/table/Table.js"],"names":["define","_","BuilderUtils","NestedComponent","TableComponent","[object Object]","numRows","numCols","rows","i","cols","j","push","components","extend","schema","label","type","input","key","emptyTable","header","caption","cloneRows","striped","bordered","hover","condensed","persistent","builderInfo","title","group","icon","weight","documentation","defaultSchema","omit","super","this","eachComponent","component","length","tableRow","tableColumn","column","className","name","cellClassName","cellAlignment","tableKey","args","noField","init","rowIndex","colIndex","slice","lastNonEmptyRow","table","each","row","cloneDeep","uniquify","root","_form","comp","createComponent","render","renderTemplate","tableComponents","map","renderComponents","element","keys","reduce","prev","loadRefs","superAttach","attach","forEach","columnIndex","attachComponents","refs","all","destroy"],"mappings":"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","file":"../../../components/table/Table.js","sourcesContent":["define([\n    'skylark-lodash',\n    '../../utils/builder',\n    '../_classes/nested/NestedComponent'\n], function (_, BuilderUtils, NestedComponent) {\n    'use strict';\n    return class TableComponent extends NestedComponent {\n        static emptyTable(numRows, numCols) {\n            const rows = [];\n            for (let i = 0; i < numRows; i++) {\n                const cols = [];\n                for (let j = 0; j < numCols; j++) {\n                    cols.push({ components: [] });\n                }\n                rows.push(cols);\n            }\n            return rows;\n        }\n        static schema(...extend) {\n            return NestedComponent.schema({\n                label: 'Table',\n                type: 'table',\n                input: false,\n                key: 'table',\n                numRows: 3,\n                numCols: 3,\n                rows: TableComponent.emptyTable(3, 3),\n                header: [],\n                caption: '',\n                cloneRows: false,\n                striped: false,\n                bordered: false,\n                hover: false,\n                condensed: false,\n                persistent: false\n            }, ...extend);\n        }\n        static get builderInfo() {\n            return {\n                title: 'Table',\n                group: 'layout',\n                icon: 'table',\n                weight: 40,\n                documentation: 'http://help.form.io/userguide/#table',\n                schema: TableComponent.schema()\n            };\n        }\n        get defaultSchema() {\n            return TableComponent.schema();\n        }\n        get schema() {\n            const schema = _.omit(super.schema, 'components');\n            schema.rows = [];\n            this.eachComponent(component => {\n                if (!schema.rows || !schema.rows.length) {\n                    schema.rows = TableComponent.emptyTable(this.component.numRows, this.component.numCols);\n                }\n                if (!schema.rows[component.tableRow]) {\n                    schema.rows[component.tableRow] = [];\n                }\n                if (!schema.rows[component.tableRow][component.tableColumn]) {\n                    schema.rows[component.tableRow][component.column] = { components: [] };\n                }\n                schema.rows[component.tableRow][component.tableColumn].components.push(component.schema);\n            });\n            if (!schema.rows.length) {\n                schema.rows = TableComponent.emptyTable(this.component.numRows, this.component.numCols);\n            }\n            return schema;\n        }\n        get className() {\n            let name = `table-responsive ${ super.className }`;\n            if (!this.component.bordered) {\n                name += ' no-top-border-table';\n            }\n            return name;\n        }\n        get cellClassName() {\n            let name = '';\n            if (this.component.cellAlignment) {\n                name = `cell-align-${ this.component.cellAlignment }`;\n            }\n            return name;\n        }\n        get tableKey() {\n            return `table-${ this.key }`;\n        }\n        constructor(...args) {\n            super(...args);\n            this.noField = true;\n        }\n        init() {\n            super.init();\n            for (let rowIndex = 0; rowIndex < this.component.numRows; rowIndex++) {\n                this.component.rows[rowIndex] = this.component.rows[rowIndex] || [];\n                for (let colIndex = 0; colIndex < this.component.numCols; colIndex++) {\n                    this.component.rows[rowIndex][colIndex] = this.component.rows[rowIndex][colIndex] || { components: [] };\n                }\n                this.component.rows[rowIndex] = this.component.rows[rowIndex].slice(0, this.component.numCols);\n            }\n            this.component.rows = this.component.rows.slice(0, this.component.numRows);\n            const lastNonEmptyRow = [];\n            this.table = [];\n            _.each(this.component.rows, (row, rowIndex) => {\n                this.table[rowIndex] = [];\n                _.each(row, (column, colIndex) => {\n                    this.table[rowIndex][colIndex] = [];\n                    if (this.component.cloneRows) {\n                        if (column.components.length) {\n                            lastNonEmptyRow[colIndex] = column;\n                        } else if (lastNonEmptyRow[colIndex]) {\n                            column.components = _.cloneDeep(lastNonEmptyRow[colIndex].components);\n                            BuilderUtils.uniquify(this.root._form.components, column);\n                        }\n                    }\n                    _.each(column.components, comp => {\n                        const component = this.createComponent(comp);\n                        component.tableRow = rowIndex;\n                        component.tableColumn = colIndex;\n                        this.table[rowIndex][colIndex].push(component);\n                    });\n                });\n            });\n        }\n        render() {\n            return super.render(this.renderTemplate('table', {\n                cellClassName: this.cellClassName,\n                tableKey: this.tableKey,\n                tableComponents: this.table.map(row => row.map(column => this.renderComponents(column)))\n            }));\n        }\n        attach(element) {\n            const keys = this.table.reduce((prev, row, rowIndex) => {\n                prev[`${ this.tableKey }-${ rowIndex }`] = 'multiple';\n                return prev;\n            }, {});\n            this.loadRefs(element, keys);\n            const superAttach = super.attach(element);\n            this.table.forEach((row, rowIndex) => {\n                row.forEach((column, columnIndex) => {\n                    this.attachComponents(this.refs[`${ this.tableKey }-${ rowIndex }`][columnIndex], this.table[rowIndex][columnIndex], this.component.rows[rowIndex][columnIndex].components);\n                });\n            });\n            return superAttach;\n        }\n        destroy(all) {\n            super.destroy(all);\n            delete this.table;\n        }\n    };\n});"]}