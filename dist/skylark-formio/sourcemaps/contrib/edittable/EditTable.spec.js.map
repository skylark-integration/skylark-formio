{"version":3,"sources":["contrib/edittable/EditTable.spec.js"],"names":["define","a","Harness","EditTable","Webform","b","testCreate","create","describe","it","done","basic","then","domRoot","document","createElement","form","setForm","title","components","type","key","rowGroups","label","numberOfRows","input","expect","_submission","metadata","to","deep","equal","A","B","Header","catch","edittable","hasColumns","be","false","schema","Object","assign","columns","true","componentSchema","have","property","getColumns","empty","getGroups","an","groups","totalRowsNumber","prototype","slice","addEmptyRows","dataValue","emptyColumn","tableClass","getRowChunks","chunks","lengthOf","comps","componentComponents","forEach","c","builder","element","querySelector","not","null","querySelectorAll","getMeta","setMeta","root"],"mappings":"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","file":"../../../contrib/edittable/EditTable.spec.js","sourcesContent":["define([\n    'chai',\n    '../../../test/harness',\n    './EditTable',\n    '../../Webform',\n    './fixtures/index'\n], function (a, Harness, EditTable, Webform, b) {\n    'use strict';\n    const {testCreate: create} = Harness;\n    describe('EditTable Component', () => {\n        it('should create component', done => {\n            create(EditTable, b.basic).then(() => done(), done);\n        });\n        it('should add row groups to form metadata', done => {\n            const domRoot = document.createElement('div');\n            const form = new Webform(domRoot);\n            form.setForm({\n                title: 'Simple Form',\n                components: [{\n                        type: 'edittable',\n                        key: 'questions',\n                        rowGroups: [\n                            {\n                                label: 'A',\n                                numberOfRows: 1\n                            },\n                            {\n                                label: 'B',\n                                numberOfRows: 1\n                            },\n                            {\n                                label: 'Header',\n                                numberOfRows: 4\n                            }\n                        ],\n                        input: true\n                    }]\n            }).then(() => {\n                a.expect(form._submission.metadata['questions']).to.deep.equal({\n                    A: 1,\n                    B: 1,\n                    Header: 4\n                });\n                done();\n            }, done).catch(done);\n        });\n        describe('hasColumns', () => {\n            it('should false if there no columns', done => {\n                create(EditTable, b.basic).then(edittable => {\n                    a.expect(edittable.hasColumns()).to.be.false;\n                    done();\n                }, done).catch(done);\n            });\n            it('should true if there columns', done => {\n                const schema = Object.assign({}, b.basic, {\n                    columns: [{\n                            key: 'name',\n                            label: 'Name'\n                        }]\n                });\n                create(EditTable, schema).then(edittable => {\n                    a.expect(edittable.hasColumns()).to.be.true;\n                    done();\n                }, done).catch(done);\n            });\n        });\n        describe('componentSchema', () => {\n            it('should return valid schema', done => {\n                create(EditTable, b.basic).then(edittable => {\n                    const schema = edittable.componentSchema();\n                    a.expect(schema).to.have.property('key');\n                    a.expect(schema).to.have.property('type');\n                    a.expect(schema).to.have.property('label');\n                    a.expect(schema).to.have.property('input');\n                    done();\n                }, done).catch(done);\n            });\n            it('should return Modal Edit schema', done => {\n                create(EditTable, b.basic).then(edittable => {\n                    const schema = edittable.componentSchema();\n                    a.expect(schema).to.have.property('key', 'modalEdit');\n                    a.expect(schema).to.have.property('type', 'modaledit');\n                    a.expect(schema).to.have.property('label', 'Modal Edit');\n                    a.expect(schema).to.have.property('input', true);\n                    done();\n                }, done).catch(done);\n            });\n        });\n        describe('getColumns', () => {\n            it('should return empty array if no columns', done => {\n                create(EditTable, b.basic).then(edittable => {\n                    a.expect(edittable.getColumns()).to.be.empty;\n                    done();\n                }, done).catch(done);\n            });\n            it('should return array of columns', done => {\n                const columns = [\n                    {\n                        key: 'name',\n                        label: 'Name'\n                    },\n                    {\n                        key: 'age',\n                        label: 'Age'\n                    }\n                ];\n                const schema = Object.assign({}, b.basic, { columns: [...columns] });\n                create(EditTable, schema).then(edittable => {\n                    a.expect(edittable.getColumns()).to.deep.equal(columns);\n                    done();\n                }, done).catch(done);\n            });\n            it('should return non-empty columns', done => {\n                const columns = [\n                    {\n                        key: '',\n                        label: ''\n                    },\n                    {\n                        key: 'name',\n                        label: 'Name'\n                    },\n                    {\n                        key: '',\n                        label: ''\n                    },\n                    {\n                        key: 'age',\n                        label: 'Age'\n                    },\n                    {\n                        key: '',\n                        label: ''\n                    }\n                ];\n                const schema = Object.assign({}, b.basic, { columns: [...columns] });\n                create(EditTable, schema).then(edittable => {\n                    a.expect(edittable.getColumns()).to.deep.equal([\n                        {\n                            key: 'name',\n                            label: 'Name'\n                        },\n                        {\n                            key: 'age',\n                            label: 'Age'\n                        }\n                    ]);\n                    done();\n                }, done).catch(done);\n            });\n        });\n        describe('getGroups', () => {\n            it('should return empty array if no row groups', done => {\n                create(EditTable, b.basic).then(edittable => {\n                    a.expect(edittable.getGroups()).to.be.an('array').empty;\n                    done();\n                }, done).catch(done);\n            });\n            it('should return row groups', done => {\n                const groups = [\n                    {\n                        label: 'A',\n                        numberOfRows: 1\n                    },\n                    {\n                        label: 'B',\n                        numberOfRows: 1\n                    }\n                ];\n                const schema = Object.assign({}, b.basic, { rowGroups: [...groups] });\n                create(EditTable, schema).then(edittable => {\n                    a.expect(edittable.getGroups()).to.deep.equal(groups);\n                    done();\n                }, done).catch(done);\n            });\n        });\n        describe('totalRowsNumber', () => {\n            it('should return the total count of rows in the provided groups', () => {\n                const groups = [\n                    {\n                        label: 'A',\n                        numberOfRows: 1\n                    },\n                    {\n                        label: 'B',\n                        numberOfRows: 2\n                    },\n                    {\n                        label: 'C',\n                        numberOfRows: 4\n                    },\n                    {\n                        label: 'D',\n                        numberOfRows: 9\n                    }\n                ];\n                const {totalRowsNumber} = EditTable.prototype;\n                a.expect(totalRowsNumber(groups)).to.equal(16);\n                a.expect(totalRowsNumber(groups.slice(1))).to.equal(15);\n                a.expect(totalRowsNumber(groups.slice(2))).to.equal(13);\n                a.expect(totalRowsNumber(groups.slice(3))).to.equal(9);\n                a.expect(totalRowsNumber(groups.slice(0, 2))).to.equal(3);\n            });\n        });\n        describe('addEmptyRows', () => {\n            it('should create an array of n empty rows and set it to dataValue', done => {\n                create(EditTable, b.basic).then(edittable => {\n                    edittable.addEmptyRows(1);\n                    a.expect(edittable.dataValue).to.deep.equal([{}]);\n                    edittable.addEmptyRows(2);\n                    a.expect(edittable.dataValue).to.deep.equal([\n                        {},\n                        {}\n                    ]);\n                    edittable.addEmptyRows(2);\n                    a.expect(edittable.dataValue).to.deep.equal([\n                        {},\n                        {}\n                    ]);\n                    edittable.addEmptyRows(3);\n                    a.expect(edittable.dataValue).to.deep.equal([\n                        {},\n                        {},\n                        {}\n                    ]);\n                    done();\n                }, done).catch(done);\n            });\n        });\n        describe('get emptyColumn', () => {\n            it('should return object that represents empty column', done => {\n                create(EditTable, b.basic).then(edittable => {\n                    a.expect(edittable.emptyColumn).to.deep.equal({\n                        label: '',\n                        key: ''\n                    });\n                    done();\n                }, done).catch(done);\n            });\n        });\n        describe('get tableClass', () => {\n            it('should return table class string', done => {\n                create(EditTable, b.basic).then(edittable => {\n                    a.expect(edittable.tableClass).to.equal('table table-bordered table-edittable form-group formio-edittable-table');\n                    done();\n                }, done).catch(done);\n            });\n        });\n        describe('getRowChunks', () => {\n            it('should return rows split by chunks according to group size', () => {\n                const {getRowChunks} = EditTable.prototype;\n                let chunks = getRowChunks([\n                    2,\n                    2\n                ], [\n                    0,\n                    0,\n                    0,\n                    0\n                ]);\n                a.expect(chunks[0]).to.be.an('array').lengthOf(2);\n                a.expect(chunks[1]).to.be.an('array').lengthOf(2);\n                chunks = getRowChunks([\n                    1,\n                    3\n                ], [\n                    1,\n                    2,\n                    3,\n                    4\n                ]);\n                a.expect(chunks[0]).to.deep.equal([1]);\n                a.expect(chunks[1]).to.deep.equal([\n                    2,\n                    3,\n                    4\n                ]);\n                chunks = getRowChunks([\n                    2,\n                    2,\n                    5,\n                    1\n                ], [\n                    1,\n                    2,\n                    3,\n                    4,\n                    5,\n                    6,\n                    7\n                ]);\n                a.expect(chunks[0]).to.deep.equal([\n                    1,\n                    2\n                ]);\n                a.expect(chunks[1]).to.deep.equal([\n                    3,\n                    4\n                ]);\n                a.expect(chunks[2]).to.deep.equal([\n                    5,\n                    6,\n                    7\n                ]);\n                a.expect(chunks[3]).to.deep.equal([]);\n                chunks = getRowChunks([\n                    0,\n                    0,\n                    0,\n                    0\n                ], [\n                    1,\n                    2,\n                    3,\n                    4,\n                    5,\n                    6,\n                    7\n                ]);\n                a.expect(chunks[0]).to.deep.equal([]);\n                a.expect(chunks[1]).to.deep.equal([]);\n                a.expect(chunks[2]).to.deep.equal([]);\n                a.expect(chunks[3]).to.deep.equal([]);\n                chunks = getRowChunks([\n                    0,\n                    0,\n                    2,\n                    2\n                ], [\n                    1,\n                    2,\n                    3,\n                    4,\n                    5,\n                    6,\n                    7\n                ]);\n                a.expect(chunks[0]).to.deep.equal([]);\n                a.expect(chunks[1]).to.deep.equal([]);\n                a.expect(chunks[2]).to.deep.equal([\n                    1,\n                    2\n                ]);\n                a.expect(chunks[3]).to.deep.equal([\n                    3,\n                    4\n                ]);\n            });\n        });\n        describe('componentComponents', () => {\n            it('should return array of component scehmas', done => {\n                const schema = Object.assign({}, b.basic, {\n                    columns: [\n                        {\n                            key: 'name',\n                            label: 'Name'\n                        },\n                        {\n                            key: 'age',\n                            label: 'Age'\n                        }\n                    ]\n                });\n                create(EditTable, schema).then(edittable => {\n                    const comps = edittable.componentComponents;\n                    comps.forEach(c => {\n                        a.expect(c).to.have.property('type');\n                        a.expect(c).to.have.property('input');\n                        a.expect(c).to.have.property('key');\n                        a.expect(c).to.have.property('label');\n                    });\n                    a.expect(comps[0].label).to.equal('Name');\n                    a.expect(comps[0].key).to.equal('name');\n                    a.expect(comps[1].label).to.equal('Age');\n                    a.expect(comps[1].key).to.equal('age');\n                    done();\n                }, done).catch(done);\n            });\n        });\n        describe('build', () => {\n            it('in builder, whit no columns, should build placeholder', done => {\n                create(EditTable, b.basic, { builder: true }).then(edittable => {\n                    a.expect(edittable.element.querySelector('.edittable-placeholder')).to.not.be.null;\n                    done();\n                }, done).catch(done);\n            });\n            it('should build table', done => {\n                create(EditTable, b.basic).then(edittable => {\n                    a.expect(edittable.element.querySelector('table')).to.not.be.null;\n                    a.expect(edittable.element.querySelector('table > tbody')).to.not.be.null;\n                    a.expect(edittable.element.querySelectorAll('table > tbody > tr')).to.have.lengthOf(1);\n                    done();\n                }, done).catch(done);\n            });\n            it('should build without add button, if ther no columns', done => {\n                create(EditTable, b.basic).then(edittable => {\n                    a.expect(edittable.element.querySelector('.btn btn-primary formio-button-add-row')).to.be.null;\n                    done();\n                }, done).catch(done);\n            });\n        });\n        describe('getMeta', () => {\n            it('should return null if no row groups', done => {\n                create(EditTable, b.basic).then(edittable => {\n                    a.expect(edittable.getMeta()).to.be.null;\n                    done();\n                }, done).catch(done);\n            });\n            it('should return meta data when row groups present', done => {\n                const groups = [\n                    {\n                        label: 'A',\n                        numberOfRows: 1\n                    },\n                    {\n                        label: 'B',\n                        numberOfRows: 1\n                    },\n                    {\n                        label: 'Header',\n                        numberOfRows: 4\n                    }\n                ];\n                const schema = Object.assign({}, b.basic, { rowGroups: [...groups] });\n                create(EditTable, schema).then(edittable => {\n                    a.expect(edittable.getMeta()).to.deep.equal({\n                        A: 1,\n                        B: 1,\n                        Header: 4\n                    });\n                    done();\n                }, done).catch(done);\n            });\n        });\n        describe('setMeta', () => {\n            it('should save row groups data to submission metadata', done => {\n                const groups = [\n                    {\n                        label: 'A',\n                        numberOfRows: 1\n                    },\n                    {\n                        label: 'B',\n                        numberOfRows: 1\n                    },\n                    {\n                        label: 'Header',\n                        numberOfRows: 4\n                    }\n                ];\n                const schema = Object.assign({}, b.basic, { rowGroups: [...groups] });\n                create(EditTable, schema).then(edittable => {\n                    const metadata = edittable.getMeta();\n                    edittable.setMeta();\n                    a.expect(edittable.root._submission.metadata[schema.key]).to.deep.equal(metadata);\n                    done();\n                }, done).catch(done);\n            });\n        });\n    });\n});"]}