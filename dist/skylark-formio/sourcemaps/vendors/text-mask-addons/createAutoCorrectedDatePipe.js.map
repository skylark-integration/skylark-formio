{"version":3,"sources":["vendors/text-mask-addons/createAutoCorrectedDatePipe.js"],"names":["define","maxValueMonth","formatOrder","dateFormat","minYear","maxYear","dateFormatArray","split","sort","a","b","indexOf","conformedValue","indexesOfPipedChars","maxValue","dd","mm","yy","yyyy","HH","MM","SS","minValue","conformedValueArr","forEach","format","position","maxFirstDigit","parseInt","toString","substr","push","month","some","length","textValue","replace","value","maxValueForFormat","scopedMaxValue","substring","join"],"mappings":";;;;;;;AAAAA,UAAU,WACR,MAAMC,GAAiB,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IACjEC,GAAe,OAAQ,KAAM,KAAM,KAAM,KAAM,KAAM,MAwD3D,OAvDA,SAAqCC,EAAa,cAAcC,QAC9DA,EAAU,EAACC,QACXA,EAAU,UAEV,MAAMC,EAAkBH,EACrBI,MAAM,cACNC,KAAK,CAACC,EAAGC,IAAMR,EAAYS,QAAQF,GAAKP,EAAYS,QAAQD,IAC/D,OAAO,SAASE,GACd,MAAMC,KACAC,GAAYC,GAAM,GAAIC,GAAM,GAAIC,GAAM,GAAIC,KAAQb,EAASc,GAAM,GAAIC,GAAM,GAAIC,GAAM,IACrFC,GAAYP,GAAM,EAAGC,GAAM,EAAGC,GAAM,EAAGC,KAAQd,EAASe,GAAM,EAAGC,GAAM,EAAGC,GAAM,GAChFE,EAAoBX,EAAeL,MAAM,IAG/CD,EAAgBkB,QAASC,IACvB,MAAMC,EAAWvB,EAAWQ,QAAQc,GAC9BE,EAAgBC,SAASd,EAASW,GAAQI,WAAWC,OAAO,EAAG,GAAI,IAErEF,SAASL,EAAkBG,GAAW,IAAMC,IAC9CJ,EAAkBG,EAAW,GAAKH,EAAkBG,GACpDH,EAAkBG,GAAY,EAC9Bb,EAAoBkB,KAAKL,MAK7B,IAAIM,EAAQ,EAkBZ,OAjBkB1B,EAAgB2B,KAAMR,IACtC,MAAMC,EAAWvB,EAAWQ,QAAQc,GAC9BS,EAAST,EAAOS,OAChBC,EAAYvB,EAAekB,OAAOJ,EAAUQ,GAAQE,QAAQ,MAAO,IACnEC,EAAQT,SAASO,EAAW,IACnB,OAAXV,IACFO,EAAQK,GAAS,GAEnB,MAAMC,EAA+B,OAAXb,EAAkBxB,EAAc+B,GAASlB,EAASW,GAC5E,GAAe,SAAXA,IAAkC,IAAZrB,GAA6B,OAAZC,GAAmB,CAC5D,MAAMkC,EAAiBX,SAASd,EAASW,GAAQI,WAAWW,UAAU,EAAGL,EAAUD,QAAS,IAE5F,OAAOG,EADgBT,SAASN,EAASG,GAAQI,WAAWW,UAAU,EAAGL,EAAUD,QAAS,KAC3DG,EAAQE,EAE3C,OAAOF,EAAQC,GAAsBH,EAAUD,SAAWA,GAAUG,EAAQf,EAASG,OAQrFY,MAAOd,EAAkBkB,KAAK,IAC9B5B,oBAAAA","file":"../../../vendors/text-mask-addons/createAutoCorrectedDatePipe.js","sourcesContent":["define([],function(){\n  const maxValueMonth = [31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  const formatOrder = ['yyyy', 'yy', 'mm', 'dd', 'HH', 'MM', 'SS']\n  function createAutoCorrectedDatePipe(dateFormat = 'mm dd yyyy', {\n    minYear = 1,\n    maxYear = 9999\n  } = {}) {\n    const dateFormatArray = dateFormat\n      .split(/[^dmyHMS]+/)\n      .sort((a, b) => formatOrder.indexOf(a) - formatOrder.indexOf(b))\n    return function(conformedValue) {\n      const indexesOfPipedChars = []\n      const maxValue = {'dd': 31, 'mm': 12, 'yy': 99, 'yyyy': maxYear, 'HH': 23, 'MM': 59, 'SS': 59}\n      const minValue = {'dd': 1, 'mm': 1, 'yy': 0, 'yyyy': minYear, 'HH': 0, 'MM': 0, 'SS': 0}\n      const conformedValueArr = conformedValue.split('')\n\n      // Check first digit\n      dateFormatArray.forEach((format) => {\n        const position = dateFormat.indexOf(format)\n        const maxFirstDigit = parseInt(maxValue[format].toString().substr(0, 1), 10)\n\n        if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {\n          conformedValueArr[position + 1] = conformedValueArr[position]\n          conformedValueArr[position] = 0\n          indexesOfPipedChars.push(position)\n        }\n      })\n\n      // Check for invalid date\n      let month = 0\n      const isInvalid = dateFormatArray.some((format) => {\n        const position = dateFormat.indexOf(format)\n        const length = format.length\n        const textValue = conformedValue.substr(position, length).replace(/\\D/g, '')\n        const value = parseInt(textValue, 10)\n        if (format === 'mm') {\n          month = value || 0\n        }\n        const maxValueForFormat = format === 'dd' ? maxValueMonth[month] : maxValue[format]\n        if (format === 'yyyy' && (minYear !== 1 || maxYear !== 9999)) {\n          const scopedMaxValue = parseInt(maxValue[format].toString().substring(0, textValue.length), 10)\n          const scopedMinValue = parseInt(minValue[format].toString().substring(0, textValue.length), 10)\n          return value < scopedMinValue || value > scopedMaxValue\n        }\n        return value > maxValueForFormat || (textValue.length === length && value < minValue[format])\n      })\n\n      if (isInvalid) {\n        return false\n      }\n\n      return {\n        value: conformedValueArr.join(''),\n        indexesOfPipedChars\n      }\n    }\n  }\n\n  return createAutoCorrectedDatePipe;\n});\n\n"]}