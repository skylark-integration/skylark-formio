{"version":3,"sources":["vendors/signature_pad/SignaturePad.js"],"names":["define","Point","Bezier","throttle","SignaturePad","canvas","options","self","this","opts","velocityFilterWeight","minWidth","maxWidth","minDistance","_strokeMoveUpdate","prototype","_strokeUpdate","dotSize","penColor","backgroundColor","onBegin","onEnd","_canvas","_ctx","getContext","clear","_handleMouseDown","event","which","_mouseButtonDown","_strokeBegin","_handleMouseMove","_handleMouseUp","_strokeEnd","_handleTouchStart","targetTouches","length","touch","changedTouches","_handleTouchMove","preventDefault","_handleTouchEnd","target","on","ctx","fillStyle","clearRect","width","height","fillRect","_data","_reset","_isEmpty","fromDataURL","dataUrl","image","Image","ratio","window","devicePixelRatio","src","onload","drawImage","toDataURL","type","_toSVG","_handleMouseEvents","_handleTouchEvents","off","removeEventListener","document","isEmpty","push","x","clientX","y","clientY","point","_createPoint","lastPointGroup","lastPoint","isLastPointTooClose","distanceTo","curve","widths","_addPoint","_drawCurve","start","end","time","color","canDrawCurve","points","_drawDot","equals","addEventListener","style","msTouchAction","touchAction","_lastVelocity","_lastWidth","rect","getBoundingClientRect","left","top","Date","getTime","tmp","unshift","c2","_calculateCurveControlPoints","c3","c1","_calculateCurveWidths","shift","s1","s2","s3","dx1","dy1","dx2","dy2","m1","m2","l1","Math","sqrt","l2","k","cm","tx","ty","startPoint","endPoint","velocity","velocityFrom","newWidth","_strokeWidth","max","_drawPoint","size","moveTo","arc","PI","startWidth","endWidth","widthDelta","drawSteps","floor","beginPath","i","t","tt","ttt","u","uu","uuu","control1","control2","closePath","fill","_fromData","pointGroups","drawCurve","drawDot","group","j","rawPoint","maxX","maxY","svg","createElementNS","setAttributeNS","path","createElement","isNaN","attr","toFixed","setAttribute","appendChild","circle","header","body","innerHTML","undefined","dummy","nodes","childNodes","cloneNode","btoa","fromData","toData"],"mappings":"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","file":"../../../vendors/signature_pad/SignaturePad.js","sourcesContent":["define([\n  './Point',\n  './bezier',\n  './throttle'\n],function(Point,Bezier,throttle){\n\n  function SignaturePad(canvas, options) {\n    const self = this;\n    const opts = options || {};\n\n    this.velocityFilterWeight = opts.velocityFilterWeight || 0.7;\n    this.minWidth = opts.minWidth || 0.5;\n    this.maxWidth = opts.maxWidth || 2.5;\n    this.throttle = 'throttle' in opts ? opts.throttle : 16; // in miliseconds\n    this.minDistance = 'minDistance' in opts ? opts.minDistance : 5;\n\n    if (this.throttle) {\n      this._strokeMoveUpdate = throttle(SignaturePad.prototype._strokeUpdate, this.throttle);\n    } else {\n      this._strokeMoveUpdate = SignaturePad.prototype._strokeUpdate;\n    }\n\n    this.dotSize = opts.dotSize || function () {\n      return (this.minWidth + this.maxWidth) / 2;\n    };\n    this.penColor = opts.penColor || 'black';\n    this.backgroundColor = opts.backgroundColor || 'rgba(0,0,0,0)';\n    this.onBegin = opts.onBegin;\n    this.onEnd = opts.onEnd;\n\n    this._canvas = canvas;\n    this._ctx = canvas.getContext('2d');\n    this.clear();\n\n    // We need add these inline so they are available to unbind while still having\n    // access to 'self' we could use _.bind but it's not worth adding a dependency.\n    this._handleMouseDown = function (event) {\n      if (event.which === 1) {\n        self._mouseButtonDown = true;\n        self._strokeBegin(event);\n      }\n    };\n\n    this._handleMouseMove = function (event) {\n      if (self._mouseButtonDown) {\n        self._strokeMoveUpdate(event);\n      }\n    };\n\n    this._handleMouseUp = function (event) {\n      if (event.which === 1 && self._mouseButtonDown) {\n        self._mouseButtonDown = false;\n        self._strokeEnd(event);\n      }\n    };\n\n    this._handleTouchStart = function (event) {\n      if (event.targetTouches.length === 1) {\n        const touch = event.changedTouches[0];\n        self._strokeBegin(touch);\n      }\n    };\n\n    this._handleTouchMove = function (event) {\n      // Prevent scrolling.\n      event.preventDefault();\n\n      const touch = event.targetTouches[0];\n      self._strokeMoveUpdate(touch);\n    };\n\n    this._handleTouchEnd = function (event) {\n      const wasCanvasTouched = event.target === self._canvas;\n      if (wasCanvasTouched) {\n        event.preventDefault();\n        self._strokeEnd(event);\n      }\n    };\n\n    // Enable mouse and touch event handlers\n    this.on();\n  }\n\n  // Public methods\n  SignaturePad.prototype.clear = function () {\n    const ctx = this._ctx;\n    const canvas = this._canvas;\n\n    ctx.fillStyle = this.backgroundColor;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    this._data = [];\n    this._reset();\n    this._isEmpty = true;\n  };\n\n  SignaturePad.prototype.fromDataURL = function (dataUrl, options = {}) {\n    const image = new Image();\n    const ratio = options.ratio || window.devicePixelRatio || 1;\n    const width = options.width || (this._canvas.width / ratio);\n    const height = options.height || (this._canvas.height / ratio);\n\n    this._reset();\n    image.src = dataUrl;\n    image.onload = () => {\n      this._ctx.drawImage(image, 0, 0, width, height);\n    };\n    this._isEmpty = false;\n  };\n\n  SignaturePad.prototype.toDataURL = function (type, ...options) {\n    switch (type) {\n      case 'image/svg+xml':\n        return this._toSVG();\n      default:\n        return this._canvas.toDataURL(type, ...options);\n    }\n  };\n\n  SignaturePad.prototype.on = function () {\n    this._handleMouseEvents();\n    this._handleTouchEvents();\n  };\n\n  SignaturePad.prototype.off = function () {\n    this._canvas.removeEventListener('mousedown', this._handleMouseDown);\n    this._canvas.removeEventListener('mousemove', this._handleMouseMove);\n    document.removeEventListener('mouseup', this._handleMouseUp);\n\n    this._canvas.removeEventListener('touchstart', this._handleTouchStart);\n    this._canvas.removeEventListener('touchmove', this._handleTouchMove);\n    this._canvas.removeEventListener('touchend', this._handleTouchEnd);\n  };\n\n  SignaturePad.prototype.isEmpty = function () {\n    return this._isEmpty;\n  };\n\n  // Private methods\n  SignaturePad.prototype._strokeBegin = function (event) {\n    this._data.push([]);\n    this._reset();\n    this._strokeUpdate(event);\n\n    if (typeof this.onBegin === 'function') {\n      this.onBegin(event);\n    }\n  };\n\n  SignaturePad.prototype._strokeUpdate = function (event) {\n    const x = event.clientX;\n    const y = event.clientY;\n\n    const point = this._createPoint(x, y);\n    const lastPointGroup = this._data[this._data.length - 1];\n    const lastPoint = lastPointGroup && lastPointGroup[lastPointGroup.length - 1];\n    const isLastPointTooClose = lastPoint && point.distanceTo(lastPoint) < this.minDistance;\n\n    // Skip this point if it's too close to the previous one\n    if (!(lastPoint && isLastPointTooClose)) {\n      const { curve, widths } = this._addPoint(point);\n\n      if (curve && widths) {\n        this._drawCurve(curve, widths.start, widths.end);\n      }\n\n      this._data[this._data.length - 1].push({\n        x: point.x,\n        y: point.y,\n        time: point.time,\n        color: this.penColor,\n      });\n    }\n  };\n\n  SignaturePad.prototype._strokeEnd = function (event) {\n    const canDrawCurve = this.points.length > 2;\n    const point = this.points[0]; // Point instance\n\n    if (!canDrawCurve && point) {\n      this._drawDot(point);\n    }\n\n    if (point) {\n      const lastPointGroup = this._data[this._data.length - 1];\n      const lastPoint = lastPointGroup[lastPointGroup.length - 1]; // plain object\n\n      // When drawing a dot, there's only one point in a group, so without this check\n      // such group would end up with exactly the same 2 points.\n      if (!point.equals(lastPoint)) {\n        lastPointGroup.push({\n          x: point.x,\n          y: point.y,\n          time: point.time,\n          color: this.penColor,\n        });\n      }\n    }\n\n    if (typeof this.onEnd === 'function') {\n      this.onEnd(event);\n    }\n  };\n\n  SignaturePad.prototype._handleMouseEvents = function () {\n    this._mouseButtonDown = false;\n\n    this._canvas.addEventListener('mousedown', this._handleMouseDown);\n    this._canvas.addEventListener('mousemove', this._handleMouseMove);\n    document.addEventListener('mouseup', this._handleMouseUp);\n  };\n\n  SignaturePad.prototype._handleTouchEvents = function () {\n    // Pass touch events to canvas element on mobile IE11 and Edge.\n    this._canvas.style.msTouchAction = 'none';\n    this._canvas.style.touchAction = 'none';\n\n    this._canvas.addEventListener('touchstart', this._handleTouchStart);\n    this._canvas.addEventListener('touchmove', this._handleTouchMove);\n    this._canvas.addEventListener('touchend', this._handleTouchEnd);\n  };\n\n  SignaturePad.prototype._reset = function () {\n    this.points = [];\n    this._lastVelocity = 0;\n    this._lastWidth = (this.minWidth + this.maxWidth) / 2;\n    this._ctx.fillStyle = this.penColor;\n  };\n\n  SignaturePad.prototype._createPoint = function (x, y, time) {\n    const rect = this._canvas.getBoundingClientRect();\n\n    return new Point(\n      x - rect.left,\n      y - rect.top,\n      time || new Date().getTime(),\n    );\n  };\n\n  SignaturePad.prototype._addPoint = function (point) {\n    const points = this.points;\n    let tmp;\n\n    points.push(point);\n\n    if (points.length > 2) {\n      // To reduce the initial lag make it work with 3 points\n      // by copying the first point to the beginning.\n      if (points.length === 3) points.unshift(points[0]);\n\n      tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);\n      const c2 = tmp.c2;\n      tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);\n      const c3 = tmp.c1;\n      const curve = new Bezier(points[1], c2, c3, points[2]);\n      const widths = this._calculateCurveWidths(curve);\n\n      // Remove the first element from the list,\n      // so that we always have no more than 4 points in points array.\n      points.shift();\n\n      return { curve, widths };\n    }\n\n    return {};\n  };\n\n  SignaturePad.prototype._calculateCurveControlPoints = function (s1, s2, s3) {\n    const dx1 = s1.x - s2.x;\n    const dy1 = s1.y - s2.y;\n    const dx2 = s2.x - s3.x;\n    const dy2 = s2.y - s3.y;\n\n    const m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n    const m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n\n    const l1 = Math.sqrt((dx1 * dx1) + (dy1 * dy1));\n    const l2 = Math.sqrt((dx2 * dx2) + (dy2 * dy2));\n\n    const dxm = (m1.x - m2.x);\n    const dym = (m1.y - m2.y);\n\n    const k = l2 / (l1 + l2);\n    const cm = { x: m2.x + (dxm * k), y: m2.y + (dym * k) };\n\n    const tx = s2.x - cm.x;\n    const ty = s2.y - cm.y;\n\n    return {\n      c1: new Point(m1.x + tx, m1.y + ty),\n      c2: new Point(m2.x + tx, m2.y + ty),\n    };\n  };\n\n  SignaturePad.prototype._calculateCurveWidths = function (curve) {\n    const startPoint = curve.startPoint;\n    const endPoint = curve.endPoint;\n    const widths = { start: null, end: null };\n\n    const velocity = (this.velocityFilterWeight * endPoint.velocityFrom(startPoint))\n     + ((1 - this.velocityFilterWeight) * this._lastVelocity);\n\n    const newWidth = this._strokeWidth(velocity);\n\n    widths.start = this._lastWidth;\n    widths.end = newWidth;\n\n    this._lastVelocity = velocity;\n    this._lastWidth = newWidth;\n\n    return widths;\n  };\n\n  SignaturePad.prototype._strokeWidth = function (velocity) {\n    return Math.max(this.maxWidth / (velocity + 1), this.minWidth);\n  };\n\n  SignaturePad.prototype._drawPoint = function (x, y, size) {\n    const ctx = this._ctx;\n\n    ctx.moveTo(x, y);\n    ctx.arc(x, y, size, 0, 2 * Math.PI, false);\n    this._isEmpty = false;\n  };\n\n  SignaturePad.prototype._drawCurve = function (curve, startWidth, endWidth) {\n    const ctx = this._ctx;\n    const widthDelta = endWidth - startWidth;\n    const drawSteps = Math.floor(curve.length());\n\n    ctx.beginPath();\n\n    for (let i = 0; i < drawSteps; i += 1) {\n      // Calculate the Bezier (x, y) coordinate for this step.\n      const t = i / drawSteps;\n      const tt = t * t;\n      const ttt = tt * t;\n      const u = 1 - t;\n      const uu = u * u;\n      const uuu = uu * u;\n\n      let x = uuu * curve.startPoint.x;\n      x += 3 * uu * t * curve.control1.x;\n      x += 3 * u * tt * curve.control2.x;\n      x += ttt * curve.endPoint.x;\n\n      let y = uuu * curve.startPoint.y;\n      y += 3 * uu * t * curve.control1.y;\n      y += 3 * u * tt * curve.control2.y;\n      y += ttt * curve.endPoint.y;\n\n      const width = startWidth + (ttt * widthDelta);\n      this._drawPoint(x, y, width);\n    }\n\n    ctx.closePath();\n    ctx.fill();\n  };\n\n  SignaturePad.prototype._drawDot = function (point) {\n    const ctx = this._ctx;\n    const width = (typeof this.dotSize) === 'function' ? this.dotSize() : this.dotSize;\n\n    ctx.beginPath();\n    this._drawPoint(point.x, point.y, width);\n    ctx.closePath();\n    ctx.fill();\n  };\n\n  SignaturePad.prototype._fromData = function (pointGroups, drawCurve, drawDot) {\n    for (let i = 0; i < pointGroups.length; i += 1) {\n      const group = pointGroups[i];\n\n      if (group.length > 1) {\n        for (let j = 0; j < group.length; j += 1) {\n          const rawPoint = group[j];\n          const point = new Point(rawPoint.x, rawPoint.y, rawPoint.time);\n          const color = rawPoint.color;\n\n          if (j === 0) {\n            // First point in a group. Nothing to draw yet.\n\n            // All points in the group have the same color, so it's enough to set\n            // penColor just at the beginning.\n            this.penColor = color;\n            this._reset();\n\n            this._addPoint(point);\n          } else if (j !== group.length - 1) {\n            // Middle point in a group.\n            const { curve, widths } = this._addPoint(point);\n            if (curve && widths) {\n              drawCurve(curve, widths, color);\n            }\n          } else {\n            // Last point in a group. Do nothing.\n          }\n        }\n      } else {\n        this._reset();\n        const rawPoint = group[0];\n        drawDot(rawPoint);\n      }\n    }\n  };\n\n  SignaturePad.prototype._toSVG = function () {\n    const pointGroups = this._data;\n    const canvas = this._canvas;\n    const ratio = Math.max(window.devicePixelRatio || 1, 1);\n    const minX = 0;\n    const minY = 0;\n    const maxX = canvas.width / ratio;\n    const maxY = canvas.height / ratio;\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n    svg.setAttributeNS(null, 'width', canvas.width);\n    svg.setAttributeNS(null, 'height', canvas.height);\n\n    this._fromData(\n      pointGroups,\n      (curve, widths, color) => {\n        const path = document.createElement('path');\n\n        // Need to check curve for NaN values, these pop up when drawing\n        // lines on the canvas that are not continuous. E.g. Sharp corners\n        // or stopping mid-stroke and than continuing without lifting mouse.\n        if (!isNaN(curve.control1.x) &&\n            !isNaN(curve.control1.y) &&\n            !isNaN(curve.control2.x) &&\n            !isNaN(curve.control2.y)) {\n          const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} `\n                     + `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} `\n                     + `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} `\n                     + `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;\n\n          path.setAttribute('d', attr);\n          path.setAttribute('stroke-width', (widths.end * 2.25).toFixed(3));\n          path.setAttribute('stroke', color);\n          path.setAttribute('fill', 'none');\n          path.setAttribute('stroke-linecap', 'round');\n\n          svg.appendChild(path);\n        }\n      },\n      (rawPoint) => {\n        const circle = document.createElement('circle');\n        const dotSize = (typeof this.dotSize) === 'function' ? this.dotSize() : this.dotSize;\n        circle.setAttribute('r', dotSize);\n        circle.setAttribute('cx', rawPoint.x);\n        circle.setAttribute('cy', rawPoint.y);\n        circle.setAttribute('fill', rawPoint.color);\n\n        svg.appendChild(circle);\n      },\n    );\n\n    const prefix = 'data:image/svg+xml;base64,';\n    const header = '<svg'\n      + ' xmlns=\"http://www.w3.org/2000/svg\"'\n      + ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"'\n      + ` viewBox=\"${minX} ${minY} ${maxX} ${maxY}\"`\n      + ` width=\"${maxX}\"`\n      + ` height=\"${maxY}\"`\n      + '>';\n    let body = svg.innerHTML;\n\n    // IE hack for missing innerHTML property on SVGElement\n    if (body === undefined) {\n      const dummy = document.createElement('dummy');\n      const nodes = svg.childNodes;\n      dummy.innerHTML = '';\n\n      for (let i = 0; i < nodes.length; i += 1) {\n        dummy.appendChild(nodes[i].cloneNode(true));\n      }\n\n      body = dummy.innerHTML;\n    }\n\n    const footer = '</svg>';\n    const data = header + body + footer;\n\n    return prefix + btoa(data);\n  };\n\n  SignaturePad.prototype.fromData = function (pointGroups) {\n    this.clear();\n\n    this._fromData(\n      pointGroups,\n      (curve, widths) => this._drawCurve(curve, widths.start, widths.end),\n      rawPoint => this._drawDot(rawPoint),\n    );\n\n    this._data = pointGroups;\n  };\n\n  SignaturePad.prototype.toData = function () {\n    return this._data;\n  };\n\n  return SignaturePad;\n});\n"]}