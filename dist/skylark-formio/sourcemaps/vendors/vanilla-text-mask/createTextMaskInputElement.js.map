{"version":3,"sources":["vendors/vanilla-text-mask/createTextMaskInputElement.js"],"names":["define","utilities","constants","adjustCaretPosition","conformToMask","convertMaskToPlaceholder","isArray","processCaretTraps","strFunction","defaultPlaceholderChar","placeholderChar","emptyString","strNone","strObject","isAndroid","navigator","test","userAgent","defer","requestAnimationFrame","setTimeout","config","state","previousConformedValue","undefined","previousPlaceholder","[object Object]","rawValue","inputElement","mask","providedMask","guide","pipe","keepCharPositions","showMask","value","placeholder","Array","safeRawValue","inputValue","isString","isNumber","String","Error","JSON","stringify","getSafeRawValue","selectionEnd","currentCaretPosition","caretTrapIndexes","maskWithoutCaretTraps","indexes","conformToMaskConfig","conformedValue","piped","pipeResults","rejected","finalConformedValue","adjustedCaretPosition","indexesOfPipedChars","inputElementValue","element","selectionPosition","document","activeElement","setSelectionRange"],"mappings":";;;;;;;AAAAA,QACE,cACA,cACA,wBACA,mBACA,SAASC,EAAUC,EAAUC,EAAoBC,GAGjD,MAAMC,yBAACA,EAAwBC,QAAEA,EAAOC,kBAAEA,GAAqBN,GACzDO,YAACA,GAAeN,EAEhBO,EAAyBP,EAAUQ,gBAEnCC,EAAc,GACdC,EAAU,OACVC,EAAY,SACZC,EAAiC,oBAAdC,WAA6B,WAAWC,KAAKD,UAAUE,WAC1EC,EAAyC,oBAA1BC,sBAAwCA,sBAAwBC,WA+LrF,OA7LA,SAAoCC,GAElC,MAAMC,GAASC,4BAAwBC,EAAWC,yBAAqBD,GAEvE,OACEF,MAAAA,EAKAI,OAAOC,GAAUC,aACfA,EACAC,KAAMC,EAAYC,MAClBA,EAAKC,KACLA,EAAItB,gBACJA,EAAkBD,EAAsBwB,kBACxCA,GAAoB,EAAKC,SACzBA,GAAW,GACTb,GAQF,QANwB,IAAbM,IACTA,EAAWC,EAAaO,OAKtBR,IAAaL,EAAMC,uBAA0B,OAYjD,IAAIa,EAIAP,EAUJ,UArBWC,IAAiBjB,QAAmCW,IAAtBM,EAAaE,WAA4CR,IAAtBM,EAAaD,OACvFG,EAAOF,EAAaE,KACpBF,EAAeA,EAAaD,MAa1BC,aAAwBO,QAC1BD,EAAc/B,EAAyByB,EAAcpB,KAKlC,IAAjBoB,EAA0B,OAI9B,MAAMQ,EAsHZ,SAAyBC,GACvB,GAAIC,SAASD,GACX,OAAOA,EACF,GAAIE,SAASF,GAClB,OAAOG,OAAOH,GACT,QAAmBf,IAAfe,GAA2C,OAAfA,EACrC,OAAO5B,EAEP,MAAM,IAAIgC,MACR,sGACqBC,KAAKC,UAAUN,MAhIfO,CAAgBnB,IAG9BoB,aAAcC,GAAwBpB,GAGvCL,uBAACA,EAAsBE,oBAAEA,GAAuBH,EAEtD,IAAI2B,EAIJ,UAAWnB,IAAiBtB,EAAa,CAIvC,IAAa,KAHbqB,EAAOC,EAAaQ,GAAeU,qBAAAA,EAAsBzB,uBAAAA,EAAwBb,gBAAAA,KAG3D,OAKtB,MAAMwC,sBAACA,EAAqBC,QAAEA,GAAW5C,EAAkBsB,GAG3DoB,EAAmBE,EAEnBf,EAAc/B,EAHdwB,EAAOqB,EAGsCxC,QAI7CmB,EAAOC,EAIT,MAAMsB,GACJ7B,uBAAAA,EACAQ,MAAAA,EACArB,gBAAAA,EACAsB,KAAAA,EACAI,YAAAA,EACAY,qBAAAA,EACAf,kBAAAA,IAIIoB,eAACA,GAAkBjD,EAAckC,EAAcT,EAAMuB,GAGrDE,SAAetB,IAASxB,EAE9B,IAAI+C,KAGAD,KAQkB,KANpBC,EAAcvB,EAAKqB,GAAiB1B,SAAUW,KAAiBc,KAQ7DG,GAAepB,MAAOZ,EAAwBiC,UAAU,GAC/ChB,SAASe,KAClBA,GAAepB,MAAOoB,KAM1B,MAAME,EAAsB,EAAUF,EAAYpB,MAAQkB,EAIpDK,EAAwBvD,GAC5BoB,uBAAAA,EACAE,oBAAAA,EACA4B,eAAgBI,EAChBrB,YAAAA,EACAT,SAAUW,EACVU,qBAAAA,EACAtC,gBAAAA,EACAiD,oBAAqBJ,EAAYI,oBACjCV,iBAAAA,IAMIW,EAF0BH,IAAwBrB,GAAyC,IAA1BsB,EACpDxB,EAAWE,EAAczB,EACuB8C,EAkBzE,IAA0BI,EAASC,EAhB7BxC,EAAMC,uBAAyBqC,EAC/BtC,EAAMG,oBAAsBW,EAKxBR,EAAaO,QAAUyB,IAI3BhC,EAAaO,MAAQyB,EAMDC,EALHjC,EAKYkC,EALEJ,EAM/BK,SAASC,gBAAkBH,IACzB/C,EACFI,EAAM,IAAM2C,EAAQI,kBAAkBH,EAAmBA,EAAmBlD,GAAU,GAEtFiD,EAAQI,kBAAkBH,EAAmBA,EAAmBlD","file":"../../../vendors/vanilla-text-mask/createTextMaskInputElement.js","sourcesContent":["define([\r\n  \"./utilities\",\r\n  \"./constants\",\r\n  \"./adjustCaretPosition\",\r\n  \"./conformToMask\"\r\n],function(utilities,constants,adjustCaretPosition,conformToMask){\r\n\r\n\r\n  const {convertMaskToPlaceholder, isArray, processCaretTraps} = utilities;\r\n  const {strFunction} = constants;\r\n\r\n  const defaultPlaceholderChar = constants.placeholderChar;\r\n\r\n  const emptyString = ''\r\n  const strNone = 'none'\r\n  const strObject = 'object'\r\n  const isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent)\r\n  const defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout\r\n\r\n  function createTextMaskInputElement(config) {\r\n    // Anything that we will need to keep between `update` calls, we will store in this `state` object.\r\n    const state = {previousConformedValue: undefined, previousPlaceholder: undefined}\r\n\r\n    return {\r\n      state,\r\n\r\n      // `update` is called by framework components whenever they want to update the `value` of the input element.\r\n      // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case\r\n      // is for this to be read from the `inputElement` directly.\r\n      update(rawValue, {\r\n        inputElement,\r\n        mask: providedMask,\r\n        guide,\r\n        pipe,\r\n        placeholderChar = defaultPlaceholderChar,\r\n        keepCharPositions = false,\r\n        showMask = false\r\n      } = config) {\r\n        // if `rawValue` is `undefined`, read from the `inputElement`\r\n        if (typeof rawValue === 'undefined') {\r\n          rawValue = inputElement.value\r\n        }\r\n\r\n        // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\r\n        // This check is here to handle controlled framework components that repeat the `update` call on every render.\r\n        if (rawValue === state.previousConformedValue) { return }\r\n\r\n        // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is\r\n        // passed, we destructure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`\r\n        // were passed.\r\n        if (typeof providedMask === strObject && providedMask.pipe !== undefined && providedMask.mask !== undefined) {\r\n          pipe = providedMask.pipe\r\n          providedMask = providedMask.mask\r\n        }\r\n\r\n        // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would\r\n        // be `(___)` if the `placeholderChar` is set to `_`.\r\n        let placeholder\r\n\r\n        // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will\r\n        // have to call that function to get the mask array.\r\n        let mask\r\n\r\n        // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\r\n        // correct `placeholder`.\r\n        if (providedMask instanceof Array) {\r\n          placeholder = convertMaskToPlaceholder(providedMask, placeholderChar)\r\n        }\r\n\r\n        // In framework components that support reactivity, it's possible to turn off masking by passing\r\n        // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\r\n        if (providedMask === false) { return }\r\n\r\n        // We check the provided `rawValue` before moving further.\r\n        // If it's something we can't work with `getSafeRawValue` will throw.\r\n        const safeRawValue = getSafeRawValue(rawValue)\r\n\r\n        // `selectionEnd` indicates to us where the caret position is after the user has typed into the input\r\n        const {selectionEnd: currentCaretPosition} = inputElement\r\n\r\n        // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call\r\n        const {previousConformedValue, previousPlaceholder} = state\r\n\r\n        let caretTrapIndexes\r\n\r\n        // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\r\n        // Then we also need to get the `placeholder`\r\n        if (typeof providedMask === strFunction) {\r\n          mask = providedMask(safeRawValue, {currentCaretPosition, previousConformedValue, placeholderChar})\r\n\r\n          // disable masking if `mask` is `false`\r\n          if (mask === false) { return }\r\n\r\n          // mask functions can setup caret traps to have some control over how the caret moves. We need to process\r\n          // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\r\n          // the indexes of the caret traps.\r\n          const {maskWithoutCaretTraps, indexes} = processCaretTraps(mask)\r\n\r\n          mask = maskWithoutCaretTraps // The processed mask is what we're interested in\r\n          caretTrapIndexes = indexes // And we need to store these indexes because they're needed by `adjustCaretPosition`\r\n\r\n          placeholder = convertMaskToPlaceholder(mask, placeholderChar)\r\n\r\n        // If the `providedMask` is not a function, we just use it as-is.\r\n        } else {\r\n          mask = providedMask\r\n        }\r\n\r\n        // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\r\n        const conformToMaskConfig = {\r\n          previousConformedValue,\r\n          guide,\r\n          placeholderChar,\r\n          pipe,\r\n          placeholder,\r\n          currentCaretPosition,\r\n          keepCharPositions\r\n        }\r\n\r\n        // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\r\n        const {conformedValue} = conformToMask(safeRawValue, mask, conformToMaskConfig)\r\n\r\n        // The following few lines are to support the `pipe` feature.\r\n        const piped = typeof pipe === strFunction\r\n\r\n        let pipeResults = {}\r\n\r\n        // If `pipe` is a function, we call it.\r\n        if (piped) {\r\n          // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\r\n          pipeResults = pipe(conformedValue, {rawValue: safeRawValue, ...conformToMaskConfig})\r\n\r\n          // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to\r\n          // indicate rejection. Or return just a string when there are no piped characters.\r\n          // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\r\n          // of the code can work with.\r\n          if (pipeResults === false) {\r\n            // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.\r\n            pipeResults = {value: previousConformedValue, rejected: true}\r\n          } else if (isString(pipeResults)) {\r\n            pipeResults = {value: pipeResults}\r\n          }\r\n        }\r\n\r\n        // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\r\n        // returned by `conformToMask`.\r\n        const finalConformedValue = (piped) ? pipeResults.value : conformedValue\r\n\r\n        // After determining the conformed value, we will need to know where to set\r\n        // the caret position. `adjustCaretPosition` will tell us.\r\n        const adjustedCaretPosition = adjustCaretPosition({\r\n          previousConformedValue,\r\n          previousPlaceholder,\r\n          conformedValue: finalConformedValue,\r\n          placeholder,\r\n          rawValue: safeRawValue,\r\n          currentCaretPosition,\r\n          placeholderChar,\r\n          indexesOfPipedChars: pipeResults.indexesOfPipedChars,\r\n          caretTrapIndexes\r\n        })\r\n\r\n        // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\r\n        const inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0\r\n        const emptyValue = showMask ? placeholder : emptyString\r\n        const inputElementValue = (inputValueShouldBeEmpty) ? emptyValue : finalConformedValue\r\n\r\n        state.previousConformedValue = inputElementValue // store value for access for next time\r\n        state.previousPlaceholder = placeholder\r\n\r\n        // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed\r\n        // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.\r\n        // See https://github.com/text-mask/text-mask/issues/231\r\n        if (inputElement.value === inputElementValue) {\r\n          return\r\n        }\r\n\r\n        inputElement.value = inputElementValue // set the input value\r\n        safeSetSelection(inputElement, adjustedCaretPosition) // adjust caret position\r\n      }\r\n    }\r\n  }\r\n\r\n  function safeSetSelection(element, selectionPosition) {\r\n    if (document.activeElement === element) {\r\n      if (isAndroid) {\r\n        defer(() => element.setSelectionRange(selectionPosition, selectionPosition, strNone), 0)\r\n      } else {\r\n        element.setSelectionRange(selectionPosition, selectionPosition, strNone)\r\n      }\r\n    }\r\n  }\r\n\r\n  function getSafeRawValue(inputValue) {\r\n    if (isString(inputValue)) {\r\n      return inputValue\r\n    } else if (isNumber(inputValue)) {\r\n      return String(inputValue)\r\n    } else if (inputValue === undefined || inputValue === null) {\r\n      return emptyString\r\n    } else {\r\n      throw new Error(\r\n        \"The 'value' provided to Text Mask needs to be a string or a number. The value \" +\r\n        `received was:\\n\\n ${JSON.stringify(inputValue)}`\r\n      )\r\n    }\r\n  }\r\n\r\n  return createTextMaskInputElement;\r\n\r\n});"]}