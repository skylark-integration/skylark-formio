{"version":3,"sources":["vendors/vanilla-text-mask/adjustCaretPosition.js"],"names":["define","defaultArray","emptyString","previousConformedValue","previousPlaceholder","currentCaretPosition","conformedValue","rawValue","placeholderChar","placeholder","indexesOfPipedChars","caretTrapIndexes","length","rawValueLength","previousConformedValueLength","placeholderLength","conformedValueLength","editLength","isAddition","trackRightCharacter","targetChar","startingSearchIndex","normalizedConformedValue","toLowerCase","intersection","substr","split","filter","char","indexOf","previousLeftMaskChars","masklengthChanged","targetIsMaskMovingLeft","undefined","countTargetCharInPipedChars","map","index","countTargetCharInIntersection","requiredNumberOfMatches","numberOfEncounteredMatches","i","lastPlaceholderChar"],"mappings":"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","file":"../../../vendors/vanilla-text-mask/adjustCaretPosition.js","sourcesContent":["define([],function(){\r\n  const defaultArray = [];\r\n  const emptyString = '';\r\n\r\n  function adjustCaretPosition({\r\n    previousConformedValue = emptyString,\r\n    previousPlaceholder = emptyString,\r\n    currentCaretPosition = 0,\r\n    conformedValue,\r\n    rawValue,\r\n    placeholderChar,\r\n    placeholder,\r\n    indexesOfPipedChars = defaultArray,\r\n    caretTrapIndexes = defaultArray\r\n  }) {\r\n    if (currentCaretPosition === 0 || !rawValue.length) { return 0 }\r\n\r\n    // Store lengths for faster performance?\r\n    const rawValueLength = rawValue.length\r\n    const previousConformedValueLength = previousConformedValue.length\r\n    const placeholderLength = placeholder.length\r\n    const conformedValueLength = conformedValue.length\r\n\r\n    // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\r\n    // we know the user in this instance pasted two characters\r\n    const editLength = rawValueLength - previousConformedValueLength\r\n\r\n    // If the edit length is positive, that means the user is adding characters, not deleting.\r\n    const isAddition = editLength > 0\r\n\r\n    // This is the first raw value the user entered that needs to be conformed to mask\r\n    const isFirstRawValue = previousConformedValueLength === 0\r\n\r\n    // A partial multi-character edit happens when the user makes a partial selection in their\r\n    // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\r\n    // selecting the first 3 digits and pressing backspace.\r\n    //\r\n    // Such cases can also happen when the user presses the backspace while holding down the ALT\r\n    // key.\r\n    const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue\r\n\r\n    // This algorithm doesn't support all cases of multi-character edits, so we just return\r\n    // the current caret position.\r\n    //\r\n    // This works fine for most cases.\r\n    if (isPartialMultiCharEdit) { return currentCaretPosition }\r\n\r\n    // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\r\n    // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\r\n    // same as the original `previousConformedValue`. We handle this case differently for caret\r\n    // positioning.\r\n    const possiblyHasRejectedChar = isAddition && (\r\n      previousConformedValue === conformedValue ||\r\n      conformedValue === placeholder\r\n    )\r\n\r\n    let startingSearchIndex = 0\r\n    let trackRightCharacter\r\n    let targetChar\r\n\r\n    if (possiblyHasRejectedChar) {\r\n      startingSearchIndex = currentCaretPosition - editLength\r\n    } else {\r\n      // At this point in the algorithm, we want to know where the caret is right before the raw input\r\n      // has been conformed, and then see if we can find that same spot in the conformed input.\r\n      //\r\n      // We do that by seeing what character lies immediately before the caret, and then look for that\r\n      // same character in the conformed input and place the caret there.\r\n\r\n      // First, we need to normalize the inputs so that letter capitalization between raw input and\r\n      // conformed input wouldn't matter.\r\n      const normalizedConformedValue = conformedValue.toLowerCase()\r\n      const normalizedRawValue = rawValue.toLowerCase()\r\n\r\n      // Then we take all characters that come before where the caret currently is.\r\n      const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString)\r\n\r\n      // Now we find all the characters in the left half that exist in the conformed input\r\n      // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\r\n      const intersection = leftHalfChars.filter((char) => normalizedConformedValue.indexOf(char) !== -1)\r\n\r\n      // The last character in the intersection is the character we want to look for in the conformed\r\n      // value and the one we want to adjust the caret close to\r\n      targetChar = intersection[intersection.length - 1]\r\n\r\n      // Calculate the number of mask characters in the previous placeholder\r\n      // from the start of the string up to the place where the caret is\r\n      const previousLeftMaskChars = previousPlaceholder\r\n        .substr(0, intersection.length)\r\n        .split(emptyString)\r\n        .filter(char => char !== placeholderChar)\r\n        .length\r\n\r\n      // Calculate the number of mask characters in the current placeholder\r\n      // from the start of the string up to the place where the caret is\r\n      const leftMaskChars = placeholder\r\n        .substr(0, intersection.length)\r\n        .split(emptyString)\r\n        .filter(char => char !== placeholderChar)\r\n        .length\r\n\r\n      // Has the number of mask characters up to the caret changed?\r\n      const masklengthChanged = leftMaskChars !== previousLeftMaskChars\r\n\r\n      // Detect if `targetChar` is a mask character and has moved to the left\r\n      const targetIsMaskMovingLeft = (\r\n        previousPlaceholder[intersection.length - 1] !== undefined &&\r\n        placeholder[intersection.length - 2] !== undefined &&\r\n        previousPlaceholder[intersection.length - 1] !== placeholderChar &&\r\n        previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] &&\r\n        previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2]\r\n      )\r\n\r\n      // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\r\n      // or the mask is moving to the left, we can't use the selected `targetChar` any longer\r\n      // if we are not at the end of the string.\r\n      // In this case, change tracking strategy and track the character to the right of the caret.\r\n      if (\r\n        !isAddition &&\r\n        (masklengthChanged || targetIsMaskMovingLeft) &&\r\n        previousLeftMaskChars > 0 &&\r\n        placeholder.indexOf(targetChar) > -1 &&\r\n        rawValue[currentCaretPosition] !== undefined\r\n      ) {\r\n        trackRightCharacter = true\r\n        targetChar = rawValue[currentCaretPosition]\r\n      }\r\n\r\n      // It is possible that `targetChar` will appear multiple times in the conformed value.\r\n      // We need to know not to select a character that looks like our target character from the placeholder or\r\n      // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\r\n      // characters that match our target character.\r\n\r\n      // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\r\n      // our `targetChar`, we don't select a piped char by mistake\r\n      const pipedChars = indexesOfPipedChars.map((index) => normalizedConformedValue[index])\r\n\r\n      // We need to know how many times the `targetChar` occurs in the piped characters.\r\n      const countTargetCharInPipedChars = pipedChars.filter((char) => char === targetChar).length\r\n\r\n      // We need to know how many times it occurs in the intersection\r\n      const countTargetCharInIntersection = intersection.filter((char) => char === targetChar).length\r\n\r\n      // We need to know if the placeholder contains characters that look like\r\n      // our `targetChar`, so we don't select one of those by mistake.\r\n      const countTargetCharInPlaceholder = placeholder\r\n        .substr(0, placeholder.indexOf(placeholderChar))\r\n        .split(emptyString)\r\n        .filter((char, index) => (\r\n          // Check if `char` is the same as our `targetChar`, so we account for it\r\n          char === targetChar &&\r\n\r\n          // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\r\n          // index because if they are equal, that means we are already counting those characters in\r\n          // `countTargetCharInIntersection`\r\n          rawValue[index] !== char\r\n        ))\r\n        .length\r\n\r\n      // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\r\n      // for is:\r\n      const requiredNumberOfMatches = (\r\n        countTargetCharInPlaceholder +\r\n        countTargetCharInIntersection +\r\n        countTargetCharInPipedChars +\r\n        // The character to the right of the caret isn't included in `intersection`\r\n        // so add one if we are tracking the character to the right\r\n        (trackRightCharacter ? 1 : 0)\r\n      )\r\n\r\n      // Now we start looking for the location of the `targetChar`.\r\n      // We keep looping forward and store the index in every iteration. Once we have encountered\r\n      // enough occurrences of the target character, we break out of the loop\r\n      // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\r\n      let numberOfEncounteredMatches = 0\r\n      for (let i = 0; i < conformedValueLength; i++) {\r\n        const conformedValueChar = normalizedConformedValue[i]\r\n\r\n        startingSearchIndex = i + 1\r\n\r\n        if (conformedValueChar === targetChar) {\r\n          numberOfEncounteredMatches++\r\n        }\r\n\r\n        if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\r\n    // most cases would be handled. However, we want to fast forward or rewind the caret to the\r\n    // closest placeholder character if it happens to be in a non-editable spot. That's what the next\r\n    // logic is for.\r\n\r\n    // In case of addition, we fast forward.\r\n    if (isAddition) {\r\n      // We want to remember the last placeholder character encountered so that if the mask\r\n      // contains more characters after the last placeholder character, we don't forward the caret\r\n      // that far to the right. Instead, we stop it at the last encountered placeholder character.\r\n      let lastPlaceholderChar = startingSearchIndex\r\n\r\n      for (let i = startingSearchIndex; i <= placeholderLength; i++) {\r\n        if (placeholder[i] === placeholderChar) {\r\n          lastPlaceholderChar = i\r\n        }\r\n\r\n        if (\r\n          // If we're adding, we can position the caret at the next placeholder character.\r\n          placeholder[i] === placeholderChar ||\r\n\r\n          // If a caret trap was set by a mask function, we need to stop at the trap.\r\n          caretTrapIndexes.indexOf(i) !== -1 ||\r\n\r\n          // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\r\n          i === placeholderLength\r\n        ) {\r\n          return lastPlaceholderChar\r\n        }\r\n      }\r\n    } else {\r\n      // In case of deletion, we rewind.\r\n      if (trackRightCharacter) {\r\n        // Searching for the character that was to the right of the caret\r\n        // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\r\n        for (let i = startingSearchIndex - 1; i >= 0; i--) {\r\n          // If tracking the character to the right of the cursor, we move to the left until\r\n          // we found the character and then place the caret right before it\r\n\r\n          if (\r\n            // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\r\n            // to the right of the caret\r\n            conformedValue[i] === targetChar ||\r\n\r\n            // If a caret trap was set by a mask function, we need to stop at the trap.\r\n            caretTrapIndexes.indexOf(i) !== -1 ||\r\n\r\n            // This is the beginning of the placeholder. We cannot move any further.\r\n            // Let's put the caret there.\r\n            i === 0\r\n          ) {\r\n            return i\r\n          }\r\n        }\r\n      } else {\r\n        // Searching for the first placeholder or caret trap to the left\r\n\r\n        for (let i = startingSearchIndex; i >= 0; i--) {\r\n          // If we're deleting, we stop the caret right before the placeholder character.\r\n          // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\r\n          // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\r\n          // right after the first `6`\r\n\r\n          if (\r\n            // If we're deleting, we can position the caret right before the placeholder character\r\n            placeholder[i - 1] === placeholderChar ||\r\n\r\n            // If a caret trap was set by a mask function, we need to stop at the trap.\r\n            caretTrapIndexes.indexOf(i) !== -1 ||\r\n\r\n            // This is the beginning of the placeholder. We cannot move any further.\r\n            // Let's put the caret there.\r\n            i === 0\r\n          ) {\r\n            return i\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return adjustCaretPosition;\r\n});"]}