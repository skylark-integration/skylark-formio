{"version":3,"sources":["vendors/vanilla-text-mask/conformToMask.js"],"names":["define","utilities","constants","convertMaskToPlaceholder","isArray","processCaretTraps","strFunction","defaultPlaceholderChar","placeholderChar","emptyArray","emptyString","rawValue","mask","config","Error","maskWithoutCaretTraps","guide","previousConformedValue","placeholder","currentCaretPosition","keepCharPositions","suppressGuide","undefined","rawValueLength","length","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","i","slice","rawValueArr","split","map","char","isNew","splice","conformedValue","someCharsRejected","placeholderLoop","charInPlaceholder","rawValueChar","shift","test","rawValueArrLength","indexOfNextAvailablePlaceholderChar","charData","substr","indexOfLastFilledPlaceholderChar","meta"],"mappings":"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","file":"../../../vendors/vanilla-text-mask/conformToMask.js","sourcesContent":["define([\r\n  \"./utilities\",\r\n  \"./constants\"\r\n],function(utilities,constants){\r\n\r\n\r\n  const {convertMaskToPlaceholder, isArray, processCaretTraps} = utilities;\r\n  const {strFunction} = constants;\r\n\r\n  const defaultPlaceholderChar = constants.placeholderChar;\r\n\r\n  const emptyArray = []\r\n  const emptyString = ''\r\n\r\n  function conformToMask(rawValue = emptyString, mask = emptyArray, config = {}) {\r\n    if (!isArray(mask)) {\r\n      // If someone passes a function as the mask property, we should call the\r\n      // function to get the mask array - Normally this is handled by the\r\n      // `createTextMaskInputElement:update` function - this allows mask functions\r\n      // to be used directly with `conformToMask`\r\n      if (typeof mask === strFunction) {\r\n        // call the mask function to get the mask array\r\n        mask = mask(rawValue, config)\r\n\r\n        // mask functions can setup caret traps to have some control over how the caret moves. We need to process\r\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\r\n        mask = processCaretTraps(mask).maskWithoutCaretTraps\r\n      } else {\r\n        throw new Error(\r\n          'Text-mask:conformToMask; The mask property must be an array.'\r\n        )\r\n      }\r\n    }\r\n\r\n    // These configurations tell us how to conform the mask\r\n    const {\r\n      guide = true,\r\n      previousConformedValue = emptyString,\r\n      placeholderChar = defaultPlaceholderChar,\r\n      placeholder = convertMaskToPlaceholder(mask, placeholderChar),\r\n      currentCaretPosition,\r\n      keepCharPositions\r\n    } = config\r\n\r\n    // The configs below indicate that the user wants the algorithm to work in *no guide* mode\r\n    const suppressGuide = guide === false && previousConformedValue !== undefined\r\n\r\n    // Calculate lengths once for performance\r\n    const rawValueLength = rawValue.length\r\n    const previousConformedValueLength = previousConformedValue.length\r\n    const placeholderLength = placeholder.length\r\n    const maskLength = mask.length\r\n\r\n    // This tells us the number of edited characters and the direction in which they were edited (+/-)\r\n    const editDistance = rawValueLength - previousConformedValueLength\r\n\r\n    // In *no guide* mode, we need to know if the user is trying to add a character or not\r\n    const isAddition = editDistance > 0\r\n\r\n    // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\r\n    const indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0)\r\n\r\n    // We're also gonna need the index of last change, which we can derive as follows...\r\n    const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance)\r\n\r\n    // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\r\n    // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\r\n    // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\r\n    // __3, not _3_ (default behavior)\r\n    //\r\n    // The next block of logic handles keeping character positions for the case of deletion. (Keeping\r\n    // character positions for the case of addition is further down since it is handled differently.)\r\n    // To do this, we want to compensate for all characters that were deleted\r\n    if (keepCharPositions === true && !isAddition) {\r\n      // We will be storing the new placeholder characters in this variable.\r\n      let compensatingPlaceholderChars = emptyString\r\n\r\n      // For every character that was deleted from a placeholder position, we add a placeholder char\r\n      for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\r\n        if (placeholder[i] === placeholderChar) {\r\n          compensatingPlaceholderChars += placeholderChar\r\n        }\r\n      }\r\n\r\n      // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\r\n      // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\r\n      // in their positions.\r\n      rawValue = (\r\n        rawValue.slice(0, indexOfFirstChange) +\r\n        compensatingPlaceholderChars +\r\n        rawValue.slice(indexOfFirstChange, rawValueLength)\r\n      )\r\n    }\r\n\r\n    // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\r\n    // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\r\n    // to work if it is configured to keep character positions.\r\n    const rawValueArr = rawValue\r\n      .split(emptyString)\r\n      .map((char, i) => ({char, isNew: i >= indexOfFirstChange && i < indexOfLastChange}))\r\n\r\n    // The loop below removes masking characters from user input. For example, for mask\r\n    // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\r\n    // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\r\n    // then would lay `234` on top of the available placeholder positions in the mask.\r\n    for (let i = rawValueLength - 1; i >= 0; i--) {\r\n      const {char} = rawValueArr[i]\r\n\r\n      if (char !== placeholderChar) {\r\n        const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength\r\n\r\n        if (char === placeholder[(shouldOffset) ? i - editDistance : i]) {\r\n          rawValueArr.splice(i, 1)\r\n        }\r\n      }\r\n    }\r\n\r\n    // This is the variable that we will be filling with characters as we figure them out\r\n    // in the algorithm below\r\n    let conformedValue = emptyString\r\n    let someCharsRejected = false\r\n\r\n    // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\r\n    placeholderLoop: for (let i = 0; i < placeholderLength; i++) {\r\n      const charInPlaceholder = placeholder[i]\r\n\r\n      // We see one. Let's find out what we can put in it.\r\n      if (charInPlaceholder === placeholderChar) {\r\n        // But before that, do we actually have any user characters that need a place?\r\n        if (rawValueArr.length > 0) {\r\n          // We will keep chipping away at user input until either we run out of characters\r\n          // or we find at least one character that we can map.\r\n          while (rawValueArr.length > 0) {\r\n            // Let's retrieve the first user character in the queue of characters we have left\r\n            const {char: rawValueChar, isNew} = rawValueArr.shift()\r\n\r\n            // If the character we got from the user input is a placeholder character (which happens\r\n            // regularly because user input could be something like (540) 90_-____, which includes\r\n            // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\r\n            // then we map this placeholder character to the current spot in the placeholder\r\n            if (rawValueChar === placeholderChar && suppressGuide !== true) {\r\n              conformedValue += placeholderChar\r\n\r\n              // And we go to find the next placeholder character that needs filling\r\n              continue placeholderLoop\r\n\r\n            // Else if, the character we got from the user input is not a placeholder, let's see\r\n            // if the current position in the mask can accept it.\r\n            } else if (mask[i].test(rawValueChar)) {\r\n              // we map the character differently based on whether we are keeping character positions or not.\r\n              // If any of the conditions below are met, we simply map the raw value character to the\r\n              // placeholder position.\r\n              if (\r\n                keepCharPositions !== true ||\r\n                isNew === false ||\r\n                previousConformedValue === emptyString ||\r\n                guide === false ||\r\n                !isAddition\r\n              ) {\r\n                conformedValue += rawValueChar\r\n              } else {\r\n                // We enter this block of code if we are trying to keep character positions and none of the conditions\r\n                // above is met. In this case, we need to see if there's an available spot for the raw value character\r\n                // to be mapped to. If we couldn't find a spot, we will discard the character.\r\n                //\r\n                // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\r\n                // `9`, to the first available placeholder position, but then, there are no more spots available for the\r\n                // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\r\n                const rawValueArrLength = rawValueArr.length\r\n                let indexOfNextAvailablePlaceholderChar = null\r\n\r\n                // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\r\n                // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\r\n                // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\r\n                // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\r\n                for (let i = 0; i < rawValueArrLength; i++) {\r\n                  const charData = rawValueArr[i]\r\n\r\n                  if (charData.char !== placeholderChar && charData.isNew === false) {\r\n                    break\r\n                  }\r\n\r\n                  if (charData.char === placeholderChar) {\r\n                    indexOfNextAvailablePlaceholderChar = i\r\n                    break\r\n                  }\r\n                }\r\n\r\n                // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\r\n                // We can map it. And to keep the character positions, we remove the placeholder character\r\n                // from the remaining characters\r\n                if (indexOfNextAvailablePlaceholderChar !== null) {\r\n                  conformedValue += rawValueChar\r\n                  rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1)\r\n\r\n                // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\r\n                // discard it.\r\n                } else {\r\n                  i--\r\n                }\r\n              }\r\n\r\n              // Since we've mapped this placeholder position. We move on to the next one.\r\n              continue placeholderLoop\r\n            } else {\r\n              someCharsRejected = true\r\n            }\r\n          }\r\n        }\r\n\r\n        // We reach this point when we've mapped all the user input characters to placeholder\r\n        // positions in the mask. In *guide* mode, we append the left over characters in the\r\n        // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\r\n        //\r\n        // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\r\n        if (suppressGuide === false) {\r\n          conformedValue += placeholder.substr(i, placeholderLength)\r\n        }\r\n\r\n        // And we break\r\n        break\r\n\r\n      // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\r\n      // with user input. So we just map it to the final output\r\n      } else {\r\n        conformedValue += charInPlaceholder\r\n      }\r\n    }\r\n\r\n    // The following logic is needed to deal with the case of deletion in *no guide* mode.\r\n    //\r\n    // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\r\n    // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\r\n    // That's why the logic below finds the last filled placeholder character, and removes everything\r\n    // from that point on.\r\n    if (suppressGuide && isAddition === false) {\r\n      let indexOfLastFilledPlaceholderChar = null\r\n\r\n      // Find the last filled placeholder position and substring from there\r\n      for (let i = 0; i < conformedValue.length; i++) {\r\n        if (placeholder[i] === placeholderChar) {\r\n          indexOfLastFilledPlaceholderChar = i\r\n        }\r\n      }\r\n\r\n      if (indexOfLastFilledPlaceholderChar !== null) {\r\n        // We substring from the beginning until the position after the last filled placeholder char.\r\n        conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1)\r\n      } else {\r\n        // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\r\n        // the first character in the mask. So we return an empty string.\r\n        conformedValue = emptyString\r\n      }\r\n    }\r\n\r\n    return {conformedValue, meta: {someCharsRejected}}\r\n  }\r\n\r\n  return conformToMask;\r\n\r\n});"]}