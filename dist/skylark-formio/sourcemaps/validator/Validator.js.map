{"version":3,"sources":["validator/Validator.js"],"names":["define","_","a","moment","NativePromise","fetchPonyfill","b","Rules","fetch","Headers","Request","Promise","ValidationChecker","[object Object]","config","this","defaults","validators","required","key","method","message","component","t","errorMessage","field","errorLabel","data","setting","value","boolValue","isValueHidden","isCalendar","some","validator","widget","enteredDate","calendar","check","call","isEmpty","unique","db","resolve","form","submission","path","query","_id","isString","$regex","RegExp","escapeRegExCharacters","$options","isPlainObject","address","isArray","$all","isObject","$eq","deleted","findOne","err","result","toString","catch","multiple","shouldBeArray","Array","emptyValue","isRequired","validate","messageKey","validateMultiple","canBeArray","length","isNil","select","index","row","async","schema","requestOptions","url","qs","json","headers","isBoolean","dataSrc","searchField","filter","includes","selectFields","interpolate","chain","map","val","encodeURIComponent","join","each","header","authenticate","token","then","response","ok","results","min","parseFloat","Number","isNaN","isNumber","max","minSelectedCount","minSelectedCountMessage","minCount","Object","keys","reduce","total","maxSelectedCount","maxSelectedCountMessage","minLength","parseInt","maxLength","maxWords","trim","split","minWords","email","test","date","day","DAY","MONTH","YEAR","dayFirst","values","x","month","year","maxDay","isLeapYear","getDaysInMonthCount","pattern","get","valid","evaluate","rowIndex","input","mask","inputMask","isMultipleMasksField","maskName","undefined","formioInputMask","getMaskByName","getInputMask","matchInputMask","custom","maxDate","getDateSetting","format","isPartialDay","isNull","setHours","isBefore","isSame","minDate","isAfter","minYear","exec","maxYear","messageText","dataValue","getWidget","settings","momentFormat","convertFormatToMoment","match","push","replace","checkInvalidDate","CALENDAR_ERROR_MESSAGES","INCOMPLETE","resultOrPromise","processResult","validatorName","conditionallyVisible","checkValidator","level","part","defaultTo","toNumber","context","label","includeWarnings","process","persistent","rootValue","validationValue","validations","resultsOrPromises","checkValidations","formatResults","all","validateCustom","customErrorMessage","hasOwnProperty","flatten","compact","error","reject","rules","validation","checkRule","prev","Rule","getRule","rule","defaultMessage","checkComponent","arguments","has","instance"],"mappings":"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","file":"../../validator/Validator.js","sourcesContent":["define([\n    'skylark-lodash',\n    '../utils/utils',\n    'skylark-moment',\n    '../vendors/getify/npo',\n    '../vendors/fetch-ponyfill/fetch',\n    '../utils/calendarUtils',\n    './Rules'\n], function (_, a, moment, NativePromise, fetchPonyfill, b, Rules) {\n    'use strict';\n    const {fetch, Headers, Request} = fetchPonyfill({ Promise: NativePromise });\n    class ValidationChecker {\n        constructor(config = {}) {\n            this.config = _.defaults(config, ValidationChecker.config);\n            this.validators = {\n                required: {\n                    key: 'validate.required',\n                    method: 'validateRequired',\n                    message(component) {\n                        return component.t(component.errorMessage('required'), {\n                            field: component.errorLabel,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        if (!a.boolValue(setting) || component.isValueHidden()) {\n                            return true;\n                        }\n                        const isCalendar = component.validators.some(validator => validator === 'calendar');\n                        if (!value && isCalendar && component.widget.enteredDate) {\n                            return !this.validators.calendar.check.call(this, component, setting, value);\n                        }\n                        return !component.isEmpty(value);\n                    }\n                },\n                unique: {\n                    key: 'validate.unique',\n                    message(component) {\n                        return component.t(component.errorMessage('unique'), {\n                            field: component.errorLabel,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        if (!a.boolValue(setting)) {\n                            return true;\n                        }\n                        if (!value || _.isEmpty(value)) {\n                            return true;\n                        }\n                        if (!this.config.db) {\n                            return true;\n                        }\n                        return new NativePromise(resolve => {\n                            const form = this.config.form;\n                            const submission = this.config.submission;\n                            const path = `data.${ component.path }`;\n                            const query = { form: form._id };\n                            if (_.isString(value)) {\n                                query[path] = {\n                                    $regex: new RegExp(`^${ a.escapeRegExCharacters(value) }$`),\n                                    $options: 'i'\n                                };\n                            } else if (_.isPlainObject(value) && value.address && value.address['address_components'] && value.address['place_id']) {\n                                query[`${ path }.address.place_id`] = {\n                                    $regex: new RegExp(`^${ a.escapeRegExCharacters(value.address['place_id']) }$`),\n                                    $options: 'i'\n                                };\n                            } else if (_.isArray(value)) {\n                                query[path] = { $all: value };\n                            } else if (_.isObject(value)) {\n                                query[path] = { $eq: value };\n                            }\n                            query.deleted = { $eq: null };\n                            this.config.db.findOne(query, (err, result) => {\n                                if (err) {\n                                    return resolve(false);\n                                } else if (result) {\n                                    return resolve(submission._id && result._id.toString() === submission._id);\n                                } else {\n                                    return resolve(true);\n                                }\n                            });\n                        }).catch(() => false);\n                    }\n                },\n                multiple: {\n                    key: 'validate.multiple',\n                    message(component) {\n                        const shouldBeArray = a.boolValue(component.component.multiple) || Array.isArray(component.emptyValue);\n                        const isRequired = component.component.validate.required;\n                        const messageKey = shouldBeArray ? isRequired ? 'array_nonempty' : 'array' : 'nonarray';\n                        return component.t(component.errorMessage(messageKey), {\n                            field: component.errorLabel,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        if (!component.validateMultiple()) {\n                            return true;\n                        }\n                        const shouldBeArray = a.boolValue(setting);\n                        const canBeArray = Array.isArray(component.emptyValue);\n                        const isArray = Array.isArray(value);\n                        const isRequired = component.component.validate.required;\n                        if (shouldBeArray) {\n                            if (isArray) {\n                                return isRequired ? !!value.length : true;\n                            } else {\n                                return _.isNil(value) ? !isRequired : false;\n                            }\n                        } else {\n                            return canBeArray || !isArray;\n                        }\n                    }\n                },\n                select: {\n                    key: 'validate.select',\n                    message(component) {\n                        return component.t(component.errorMessage('select'), {\n                            field: component.errorLabel,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value, data, index, row, async) {\n                        if (!a.boolValue(setting)) {\n                            return true;\n                        }\n                        if (!value || _.isEmpty(value)) {\n                            return true;\n                        }\n                        if (!async) {\n                            return true;\n                        }\n                        const schema = component.component;\n                        const requestOptions = {\n                            url: setting,\n                            method: 'GET',\n                            qs: {},\n                            json: true,\n                            headers: {}\n                        };\n                        if (_.isBoolean(requestOptions.url)) {\n                            requestOptions.url = !!requestOptions.url;\n                            if (!requestOptions.url || schema.dataSrc !== 'url' || !schema.data.url || !schema.searchField) {\n                                return true;\n                            }\n                            requestOptions.url = schema.data.url;\n                            requestOptions.qs[schema.searchField] = value;\n                            if (schema.filter) {\n                                requestOptions.url += (!requestOptions.url.includes('?') ? '?' : '&') + schema.filter;\n                            }\n                            if (schema.selectFields) {\n                                requestOptions.qs.select = schema.selectFields;\n                            }\n                        }\n                        if (!requestOptions.url) {\n                            return true;\n                        }\n                        requestOptions.url = a.interpolate(requestOptions.url, { data: component.data });\n                        requestOptions.url += (requestOptions.url.includes('?') ? '&' : '?') + _.chain(requestOptions.qs).map((val, key) => `${ encodeURIComponent(key) }=${ encodeURIComponent(val) }`).join('&').value();\n                        if (schema.data && schema.data.headers) {\n                            _.each(schema.data.headers, header => {\n                                if (header.key) {\n                                    requestOptions.headers[header.key] = header.value;\n                                }\n                            });\n                        }\n                        if (schema.authenticate && this.config.token) {\n                            requestOptions.headers['x-jwt-token'] = this.config.token;\n                        }\n                        return fetch(new Request(requestOptions.url, { headers: new Headers(requestOptions.headers) })).then(response => {\n                            if (!response.ok) {\n                                return false;\n                            }\n                            return response.json();\n                        }).then(results => {\n                            return results && results.length;\n                        }).catch(() => false);\n                    }\n                },\n                min: {\n                    key: 'validate.min',\n                    message(component, setting) {\n                        return component.t(component.errorMessage('min'), {\n                            field: component.errorLabel,\n                            min: parseFloat(setting),\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        const min = parseFloat(setting);\n                        if (Number.isNaN(min) || !_.isNumber(value)) {\n                            return true;\n                        }\n                        return parseFloat(value) >= min;\n                    }\n                },\n                max: {\n                    key: 'validate.max',\n                    message(component, setting) {\n                        return component.t(component.errorMessage('max'), {\n                            field: component.errorLabel,\n                            max: parseFloat(setting),\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        const max = parseFloat(setting);\n                        if (Number.isNaN(max) || !_.isNumber(value)) {\n                            return true;\n                        }\n                        return parseFloat(value) <= max;\n                    }\n                },\n                minSelectedCount: {\n                    key: 'validate.minSelectedCount',\n                    message(component, setting) {\n                        return component.component.minSelectedCountMessage ? component.component.minSelectedCountMessage : component.t(component.errorMessage('minSelectedCount'), {\n                            minCount: parseFloat(setting),\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        const min = parseFloat(setting);\n                        if (!min) {\n                            return true;\n                        }\n                        const count = Object.keys(value).reduce((total, key) => {\n                            if (value[key]) {\n                                total++;\n                            }\n                            return total;\n                        }, 0);\n                        return count >= min;\n                    }\n                },\n                maxSelectedCount: {\n                    key: 'validate.maxSelectedCount',\n                    message(component, setting) {\n                        return component.component.maxSelectedCountMessage ? component.component.maxSelectedCountMessage : component.t(component.errorMessage('maxSelectedCount'), {\n                            minCount: parseFloat(setting),\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        const max = parseFloat(setting);\n                        if (!max) {\n                            return true;\n                        }\n                        const count = Object.keys(value).reduce((total, key) => {\n                            if (value[key]) {\n                                total++;\n                            }\n                            return total;\n                        }, 0);\n                        return count <= max;\n                    }\n                },\n                minLength: {\n                    key: 'validate.minLength',\n                    message(component, setting) {\n                        return component.t(component.errorMessage('minLength'), {\n                            field: component.errorLabel,\n                            length: setting,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        const minLength = parseInt(setting, 10);\n                        if (!minLength || typeof value !== 'string' || component.isEmpty(value)) {\n                            return true;\n                        }\n                        return value.length >= minLength;\n                    }\n                },\n                maxLength: {\n                    key: 'validate.maxLength',\n                    message(component, setting) {\n                        return component.t(component.errorMessage('maxLength'), {\n                            field: component.errorLabel,\n                            length: setting,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        const maxLength = parseInt(setting, 10);\n                        if (!maxLength || typeof value !== 'string') {\n                            return true;\n                        }\n                        return value.length <= maxLength;\n                    }\n                },\n                maxWords: {\n                    key: 'validate.maxWords',\n                    message(component, setting) {\n                        return component.t(component.errorMessage('maxWords'), {\n                            field: component.errorLabel,\n                            length: setting,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        const maxWords = parseInt(setting, 10);\n                        if (!maxWords || typeof value !== 'string') {\n                            return true;\n                        }\n                        return value.trim().split(/\\s+/).length <= maxWords;\n                    }\n                },\n                minWords: {\n                    key: 'validate.minWords',\n                    message(component, setting) {\n                        return component.t(component.errorMessage('minWords'), {\n                            field: component.errorLabel,\n                            length: setting,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        const minWords = parseInt(setting, 10);\n                        if (!minWords || typeof value !== 'string') {\n                            return true;\n                        }\n                        return value.trim().split(/\\s+/).length >= minWords;\n                    }\n                },\n                email: {\n                    message(component) {\n                        return component.t(component.errorMessage('invalid_email'), {\n                            field: component.errorLabel,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        const re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n                        return !value || re.test(value);\n                    }\n                },\n                url: {\n                    message(component) {\n                        return component.t(component.errorMessage('invalid_url'), {\n                            field: component.errorLabel,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        const re = /[-a-zA-Z0-9@:%._+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/;\n                        return !value || re.test(value);\n                    }\n                },\n                date: {\n                    message(component) {\n                        return component.t(component.errorMessage('invalid_date'), {\n                            field: component.errorLabel,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        return value !== 'Invalid date';\n                    }\n                },\n                day: {\n                    message(component) {\n                        return component.t(component.errorMessage('invalid_day'), {\n                            field: component.errorLabel,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        if (!value) {\n                            return true;\n                        }\n                        const [DAY, MONTH, YEAR] = component.dayFirst ? [\n                            0,\n                            1,\n                            2\n                        ] : [\n                            1,\n                            0,\n                            2\n                        ];\n                        const values = value.split('/').map(x => parseInt(x, 10)), day = values[DAY], month = values[MONTH], year = values[YEAR], maxDay = getDaysInMonthCount(month, year);\n                        if (day < 0 || day > maxDay) {\n                            return false;\n                        }\n                        if (month < 0 || month > 12) {\n                            return false;\n                        }\n                        if (year < 0 || year > 9999) {\n                            return false;\n                        }\n                        return true;\n                        function isLeapYear(year) {\n                            return !(year % 400) || !!(year % 100) && !(year % 4);\n                        }\n                        function getDaysInMonthCount(month, year) {\n                            switch (month) {\n                            case 1:\n                            case 3:\n                            case 5:\n                            case 7:\n                            case 8:\n                            case 10:\n                            case 12:\n                                return 31;\n                            case 4:\n                            case 6:\n                            case 9:\n                            case 11:\n                                return 30;\n                            case 2:\n                                return isLeapYear(year) ? 29 : 28;\n                            default:\n                                return 31;\n                            }\n                        }\n                    }\n                },\n                pattern: {\n                    key: 'validate.pattern',\n                    message(component, setting) {\n                        return component.t(_.get(component, 'component.validate.patternMessage', component.errorMessage('pattern'), {\n                            field: component.errorLabel,\n                            pattern: setting,\n                            data: component.data\n                        }));\n                    },\n                    check(component, setting, value) {\n                        const pattern = setting;\n                        if (!pattern) {\n                            return true;\n                        }\n                        const regex = new RegExp(`^${ pattern }$`);\n                        return regex.test(value);\n                    }\n                },\n                json: {\n                    key: 'validate.json',\n                    check(component, setting, value, data, index, row) {\n                        if (!setting) {\n                            return true;\n                        }\n                        const valid = component.evaluate(setting, {\n                            data,\n                            row,\n                            rowIndex: index,\n                            input: value\n                        });\n                        if (valid === null) {\n                            return true;\n                        }\n                        return valid;\n                    }\n                },\n                mask: {\n                    key: 'inputMask',\n                    message(component) {\n                        return component.t(component.errorMessage('mask'), {\n                            field: component.errorLabel,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value) {\n                        let inputMask;\n                        if (component.isMultipleMasksField) {\n                            const maskName = value ? value.maskName : undefined;\n                            const formioInputMask = component.getMaskByName(maskName);\n                            if (formioInputMask) {\n                                inputMask = formioInputMask;\n                            }\n                            value = value ? value.value : value;\n                        } else {\n                            inputMask = setting;\n                        }\n                        inputMask = inputMask ? a.getInputMask(inputMask) : null;\n                        if (value && inputMask) {\n                            return a.matchInputMask(value, inputMask);\n                        }\n                        return true;\n                    }\n                },\n                custom: {\n                    key: 'validate.custom',\n                    message(component) {\n                        return component.t(component.errorMessage('custom'), {\n                            field: component.errorLabel,\n                            data: component.data\n                        });\n                    },\n                    check(component, setting, value, data, index, row) {\n                        if (!setting) {\n                            return true;\n                        }\n                        const valid = component.evaluate(setting, {\n                            valid: true,\n                            data,\n                            rowIndex: index,\n                            row,\n                            input: value\n                        }, 'valid', true);\n                        if (valid === null) {\n                            return true;\n                        }\n                        return valid;\n                    }\n                },\n                maxDate: {\n                    key: 'maxDate',\n                    message(component, setting) {\n                        const date = a.getDateSetting(setting);\n                        return component.t(component.errorMessage('maxDate'), {\n                            field: component.errorLabel,\n                            maxDate: moment(date).format(component.format)\n                        });\n                    },\n                    check(component, setting, value) {\n                        if (component.isPartialDay && component.isPartialDay(value)) {\n                            return true;\n                        }\n                        const date = moment(value);\n                        const maxDate = a.getDateSetting(setting);\n                        if (_.isNull(maxDate)) {\n                            return true;\n                        } else {\n                            maxDate.setHours(0, 0, 0, 0);\n                        }\n                        return date.isBefore(maxDate) || date.isSame(maxDate);\n                    }\n                },\n                minDate: {\n                    key: 'minDate',\n                    message(component, setting) {\n                        const date = a.getDateSetting(setting);\n                        return component.t(component.errorMessage('minDate'), {\n                            field: component.errorLabel,\n                            minDate: moment(date).format(component.format)\n                        });\n                    },\n                    check(component, setting, value) {\n                        if (component.isPartialDay && component.isPartialDay(value)) {\n                            return true;\n                        }\n                        const date = moment(value);\n                        const minDate = a.getDateSetting(setting);\n                        if (_.isNull(minDate)) {\n                            return true;\n                        } else {\n                            minDate.setHours(0, 0, 0, 0);\n                        }\n                        return date.isAfter(minDate) || date.isSame(minDate);\n                    }\n                },\n                minYear: {\n                    key: 'minYear',\n                    message(component, setting) {\n                        return component.t(component.errorMessage('minYear'), {\n                            field: component.errorLabel,\n                            minYear: setting\n                        });\n                    },\n                    check(component, setting, value) {\n                        const minYear = setting;\n                        let year = /\\d{4}$/.exec(value);\n                        year = year ? year[0] : null;\n                        if (!+minYear || !+year) {\n                            return true;\n                        }\n                        return +year >= +minYear;\n                    }\n                },\n                maxYear: {\n                    key: 'maxYear',\n                    message(component, setting) {\n                        return component.t(component.errorMessage('maxYear'), {\n                            field: component.errorLabel,\n                            maxYear: setting\n                        });\n                    },\n                    check(component, setting, value) {\n                        const maxYear = setting;\n                        let year = /\\d{4}$/.exec(value);\n                        year = year ? year[0] : null;\n                        if (!+maxYear || !+year) {\n                            return true;\n                        }\n                        return +year <= +maxYear;\n                    }\n                },\n                calendar: {\n                    key: 'validate.calendar',\n                    messageText: '',\n                    message(component) {\n                        return component.t(component.errorMessage(this.validators.calendar.messageText), {\n                            field: component.errorLabel,\n                            maxDate: moment(component.dataValue).format(component.format)\n                        });\n                    },\n                    check(component, setting, value, data, index) {\n                        this.validators.calendar.messageText = '';\n                        const widget = component.getWidget(index);\n                        if (!widget) {\n                            return true;\n                        }\n                        const {settings, enteredDate} = widget;\n                        const {minDate, maxDate, format} = settings;\n                        const momentFormat = [a.convertFormatToMoment(format)];\n                        if (momentFormat[0].match(/M{3,}/g)) {\n                            momentFormat.push(momentFormat[0].replace(/M{3,}/g, 'MM'));\n                        }\n                        if (!value && enteredDate) {\n                            const {message, result} = b.checkInvalidDate(enteredDate, momentFormat, minDate, maxDate);\n                            if (!result) {\n                                this.validators.calendar.messageText = message;\n                                return result;\n                            }\n                        }\n                        if (value && enteredDate) {\n                            if (moment(value).format() !== moment(enteredDate, momentFormat, true).format() && enteredDate.match(/_/gi)) {\n                                this.validators.calendar.messageText = b.CALENDAR_ERROR_MESSAGES.INCOMPLETE;\n                                return false;\n                            } else {\n                                widget.enteredDate = '';\n                                return true;\n                            }\n                        }\n                    }\n                }\n            };\n        }\n        checkValidator(component, validator, setting, value, data, index, row, async) {\n            let resultOrPromise = null;\n            if (validator.method && typeof component[validator.method] === 'function') {\n                resultOrPromise = component[validator.method](setting, value, data, index, row, async);\n            } else {\n                resultOrPromise = validator.check.call(this, component, setting, value, data, index, row, async);\n            }\n            const processResult = result => {\n                if (typeof result === 'string') {\n                    return result;\n                }\n                if (!result && validator.message) {\n                    return validator.message.call(this, component, setting, index, row);\n                }\n                return '';\n            };\n            if (async) {\n                return NativePromise.resolve(resultOrPromise).then(processResult);\n            } else {\n                return processResult(resultOrPromise);\n            }\n        }\n        validate(component, validatorName, value, data, index, row, async) {\n            if (!component.conditionallyVisible()) {\n                return false;\n            }\n            const validator = this.validators[validatorName];\n            const setting = _.get(component.component, validator.key, null);\n            const resultOrPromise = this.checkValidator(component, validator, setting, value, data, index, row, async);\n            const processResult = result => {\n                return result ? {\n                    message: _.get(result, 'message', result),\n                    level: _.get(result, 'level') === 'warning' ? 'warning' : 'error',\n                    path: (component.path || '').replace(/[[\\]]/g, '.').replace(/\\.\\./g, '.').split('.').map(part => _.defaultTo(_.toNumber(part), part)),\n                    context: {\n                        validator: validatorName,\n                        setting,\n                        key: component.key,\n                        label: component.label,\n                        value\n                    }\n                } : false;\n            };\n            if (async) {\n                return NativePromise.resolve(resultOrPromise).then(processResult);\n            } else {\n                return processResult(resultOrPromise);\n            }\n        }\n        checkComponent(component, data, row, includeWarnings = false, async = false) {\n            const isServerSidePersistent = typeof process !== 'undefined' && _.get(process, 'release.name') === 'node' && !_.defaultTo(component.component.persistent, true);\n            if (isServerSidePersistent || component.component.validate === false) {\n                return async ? NativePromise.resolve([]) : [];\n            }\n            data = data || component.rootValue;\n            row = row || component.data;\n            const values = component.component.multiple && Array.isArray(component.validationValue) ? component.validationValue : [component.validationValue];\n            const validations = _.get(component, 'component.validations');\n            if (validations && Array.isArray(validations)) {\n                const resultsOrPromises = this.checkValidations(component, validations, data, row, values, async);\n                const formatResults = results => {\n                    return includeWarnings ? results : results.filter(result => result.level === 'error');\n                };\n                if (async) {\n                    return NativePromise.all(resultsOrPromises).then(formatResults);\n                } else {\n                    return formatResults(resultsOrPromises);\n                }\n            }\n            const validateCustom = _.get(component, 'component.validate.custom');\n            const customErrorMessage = _.get(component, 'component.validate.customMessage');\n            const resultsOrPromises = _(component.validators).chain().map(validatorName => {\n                if (!this.validators.hasOwnProperty(validatorName)) {\n                    return {\n                        message: `Validator for \"${ validatorName }\" is not defined`,\n                        level: 'warning',\n                        context: {\n                            validator: validatorName,\n                            key: component.key,\n                            label: component.label\n                        }\n                    };\n                }\n                if (validatorName === 'required' && !values.length) {\n                    return [this.validate(component, validatorName, null, data, 0, row, async)];\n                }\n                return _.map(values, (value, index) => this.validate(component, validatorName, value, data, index, row, async));\n            }).flatten().value();\n            component.component.validate = component.component.validate || {};\n            component.component.validate.unique = component.component.unique;\n            resultsOrPromises.push(this.validate(component, 'unique', component.validationValue, data, 0, data, async));\n            component.component.validate.multiple = component.component.multiple;\n            resultsOrPromises.push(this.validate(component, 'multiple', component.validationValue, data, 0, data, async));\n            const formatResults = results => {\n                results = _(results).chain().flatten().compact().value();\n                if (customErrorMessage || validateCustom) {\n                    _.each(results, result => {\n                        result.message = component.t(customErrorMessage || result.message, {\n                            field: component.errorLabel,\n                            data,\n                            row,\n                            error: result\n                        });\n                    });\n                }\n                return includeWarnings ? results : _.reject(results, result => result.level === 'warning');\n            };\n            if (async) {\n                return NativePromise.all(resultsOrPromises).then(formatResults);\n            } else {\n                return formatResults(resultsOrPromises);\n            }\n        }\n        checkValidations(component, validations, data, row, values, async) {\n            const results = validations.map(validation => {\n                return this.checkRule(component, validation, data, row, values, async);\n            });\n            const messages = results.reduce((prev, result) => {\n                if (result) {\n                    return [\n                        ...prev,\n                        ...result\n                    ];\n                }\n                return prev;\n            }, []).filter(result => result);\n            const rules = messages.reduce((prev, message) => {\n                prev[message.context.validator] = message;\n                return prev;\n            }, {});\n            return Object.values(rules);\n        }\n        checkRule(component, validation, data, row, values, async) {\n            const Rule = Rules.getRule(validation.rule);\n            const results = [];\n            if (Rule) {\n                const rule = new Rule(component, validation.settings, this.config);\n                values.map((value, index) => {\n                    const result = rule.check(value, data, row, async);\n                    if (result !== true) {\n                        results.push({\n                            level: validation.level || 'error',\n                            message: component.t(validation.message || rule.defaultMessage, {\n                                settings: validation.settings,\n                                field: component.errorLabel,\n                                data,\n                                row,\n                                error: result\n                            }),\n                            context: {\n                                key: component.key,\n                                index,\n                                label: component.label,\n                                validator: validation.rule\n                            }\n                        });\n                    }\n                });\n            }\n            return results.length === 0 ? false : results;\n        }\n        get check() {\n            return this.checkComponent;\n        }\n        get() {\n            _.get.call(this, arguments);\n        }\n        each() {\n            _.each.call(this, arguments);\n        }\n        has() {\n            _.has.call(this, arguments);\n        }\n    }\n    ValidationChecker.config = {\n        db: null,\n        token: null,\n        form: null,\n        submission: null\n    };\n    const instance = ValidationChecker.instance = new ValidationChecker();\n    return  ValidationChecker.instance;\n});"]}