/**
 * skylark-formio - A version of formio.js that ported to running on skylarkjs.
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-formio/
 * @license MIT
 */
define(["chai","../../../test/harness","./EditTable","../../Webform","./fixtures/index"],function(e,t,o,a,l){"use strict";const{testCreate:c}=t;describe("EditTable Component",()=>{it("should create component",e=>{c(o,l.basic).then(()=>e(),e)}),it("should add row groups to form metadata",t=>{const o=document.createElement("div"),l=new a(o);l.setForm({title:"Simple Form",components:[{type:"edittable",key:"questions",rowGroups:[{label:"A",numberOfRows:1},{label:"B",numberOfRows:1},{label:"Header",numberOfRows:4}],input:!0}]}).then(()=>{e.expect(l._submission.metadata.questions).to.deep.equal({A:1,B:1,Header:4}),t()},t).catch(t)}),describe("hasColumns",()=>{it("should false if there no columns",t=>{c(o,l.basic).then(o=>{e.expect(o.hasColumns()).to.be.false,t()},t).catch(t)}),it("should true if there columns",t=>{const a=Object.assign({},l.basic,{columns:[{key:"name",label:"Name"}]});c(o,a).then(o=>{e.expect(o.hasColumns()).to.be.true,t()},t).catch(t)})}),describe("componentSchema",()=>{it("should return valid schema",t=>{c(o,l.basic).then(o=>{const a=o.componentSchema();e.expect(a).to.have.property("key"),e.expect(a).to.have.property("type"),e.expect(a).to.have.property("label"),e.expect(a).to.have.property("input"),t()},t).catch(t)}),it("should return Modal Edit schema",t=>{c(o,l.basic).then(o=>{const a=o.componentSchema();e.expect(a).to.have.property("key","modalEdit"),e.expect(a).to.have.property("type","modaledit"),e.expect(a).to.have.property("label","Modal Edit"),e.expect(a).to.have.property("input",!0),t()},t).catch(t)})}),describe("getColumns",()=>{it("should return empty array if no columns",t=>{c(o,l.basic).then(o=>{e.expect(o.getColumns()).to.be.empty,t()},t).catch(t)}),it("should return array of columns",t=>{const a=[{key:"name",label:"Name"},{key:"age",label:"Age"}],s=Object.assign({},l.basic,{columns:[...a]});c(o,s).then(o=>{e.expect(o.getColumns()).to.deep.equal(a),t()},t).catch(t)}),it("should return non-empty columns",t=>{const a=Object.assign({},l.basic,{columns:[...[{key:"",label:""},{key:"name",label:"Name"},{key:"",label:""},{key:"age",label:"Age"},{key:"",label:""}]]});c(o,a).then(o=>{e.expect(o.getColumns()).to.deep.equal([{key:"name",label:"Name"},{key:"age",label:"Age"}]),t()},t).catch(t)})}),describe("getGroups",()=>{it("should return empty array if no row groups",t=>{c(o,l.basic).then(o=>{e.expect(o.getGroups()).to.be.an("array").empty,t()},t).catch(t)}),it("should return row groups",t=>{const a=[{label:"A",numberOfRows:1},{label:"B",numberOfRows:1}],s=Object.assign({},l.basic,{rowGroups:[...a]});c(o,s).then(o=>{e.expect(o.getGroups()).to.deep.equal(a),t()},t).catch(t)})}),describe("totalRowsNumber",()=>{it("should return the total count of rows in the provided groups",()=>{const t=[{label:"A",numberOfRows:1},{label:"B",numberOfRows:2},{label:"C",numberOfRows:4},{label:"D",numberOfRows:9}],{totalRowsNumber:a}=o.prototype;e.expect(a(t)).to.equal(16),e.expect(a(t.slice(1))).to.equal(15),e.expect(a(t.slice(2))).to.equal(13),e.expect(a(t.slice(3))).to.equal(9),e.expect(a(t.slice(0,2))).to.equal(3)})}),describe("addEmptyRows",()=>{it("should create an array of n empty rows and set it to dataValue",t=>{c(o,l.basic).then(o=>{o.addEmptyRows(1),e.expect(o.dataValue).to.deep.equal([{}]),o.addEmptyRows(2),e.expect(o.dataValue).to.deep.equal([{},{}]),o.addEmptyRows(2),e.expect(o.dataValue).to.deep.equal([{},{}]),o.addEmptyRows(3),e.expect(o.dataValue).to.deep.equal([{},{},{}]),t()},t).catch(t)})}),describe("get emptyColumn",()=>{it("should return object that represents empty column",t=>{c(o,l.basic).then(o=>{e.expect(o.emptyColumn).to.deep.equal({label:"",key:""}),t()},t).catch(t)})}),describe("get tableClass",()=>{it("should return table class string",t=>{c(o,l.basic).then(o=>{e.expect(o.tableClass).to.equal("table table-bordered table-edittable form-group formio-edittable-table"),t()},t).catch(t)})}),describe("getRowChunks",()=>{it("should return rows split by chunks according to group size",()=>{const{getRowChunks:t}=o.prototype;let a=t([2,2],[0,0,0,0]);e.expect(a[0]).to.be.an("array").lengthOf(2),e.expect(a[1]).to.be.an("array").lengthOf(2),a=t([1,3],[1,2,3,4]),e.expect(a[0]).to.deep.equal([1]),e.expect(a[1]).to.deep.equal([2,3,4]),a=t([2,2,5,1],[1,2,3,4,5,6,7]),e.expect(a[0]).to.deep.equal([1,2]),e.expect(a[1]).to.deep.equal([3,4]),e.expect(a[2]).to.deep.equal([5,6,7]),e.expect(a[3]).to.deep.equal([]),a=t([0,0,0,0],[1,2,3,4,5,6,7]),e.expect(a[0]).to.deep.equal([]),e.expect(a[1]).to.deep.equal([]),e.expect(a[2]).to.deep.equal([]),e.expect(a[3]).to.deep.equal([]),a=t([0,0,2,2],[1,2,3,4,5,6,7]),e.expect(a[0]).to.deep.equal([]),e.expect(a[1]).to.deep.equal([]),e.expect(a[2]).to.deep.equal([1,2]),e.expect(a[3]).to.deep.equal([3,4])})}),describe("componentComponents",()=>{it("should return array of component scehmas",t=>{const a=Object.assign({},l.basic,{columns:[{key:"name",label:"Name"},{key:"age",label:"Age"}]});c(o,a).then(o=>{const a=o.componentComponents;a.forEach(t=>{e.expect(t).to.have.property("type"),e.expect(t).to.have.property("input"),e.expect(t).to.have.property("key"),e.expect(t).to.have.property("label")}),e.expect(a[0].label).to.equal("Name"),e.expect(a[0].key).to.equal("name"),e.expect(a[1].label).to.equal("Age"),e.expect(a[1].key).to.equal("age"),t()},t).catch(t)})}),describe("build",()=>{it("in builder, whit no columns, should build placeholder",t=>{c(o,l.basic,{builder:!0}).then(o=>{e.expect(o.element.querySelector(".edittable-placeholder")).to.not.be.null,t()},t).catch(t)}),it("should build table",t=>{c(o,l.basic).then(o=>{e.expect(o.element.querySelector("table")).to.not.be.null,e.expect(o.element.querySelector("table > tbody")).to.not.be.null,e.expect(o.element.querySelectorAll("table > tbody > tr")).to.have.lengthOf(1),t()},t).catch(t)}),it("should build without add button, if ther no columns",t=>{c(o,l.basic).then(o=>{e.expect(o.element.querySelector(".btn btn-primary formio-button-add-row")).to.be.null,t()},t).catch(t)})}),describe("getMeta",()=>{it("should return null if no row groups",t=>{c(o,l.basic).then(o=>{e.expect(o.getMeta()).to.be.null,t()},t).catch(t)}),it("should return meta data when row groups present",t=>{const a=Object.assign({},l.basic,{rowGroups:[...[{label:"A",numberOfRows:1},{label:"B",numberOfRows:1},{label:"Header",numberOfRows:4}]]});c(o,a).then(o=>{e.expect(o.getMeta()).to.deep.equal({A:1,B:1,Header:4}),t()},t).catch(t)})}),describe("setMeta",()=>{it("should save row groups data to submission metadata",t=>{const a=Object.assign({},l.basic,{rowGroups:[...[{label:"A",numberOfRows:1},{label:"B",numberOfRows:1},{label:"Header",numberOfRows:4}]]});c(o,a).then(o=>{const l=o.getMeta();o.setMeta(),e.expect(o.root._submission.metadata[a.key]).to.deep.equal(l),t()},t).catch(t)})})})});
//# sourceMappingURL=../../sourcemaps/contrib/edittable/EditTable.spec.js.map
